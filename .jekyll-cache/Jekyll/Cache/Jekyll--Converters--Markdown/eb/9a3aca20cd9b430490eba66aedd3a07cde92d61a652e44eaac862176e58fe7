I"<h2 id="jpql-이란">JPQL 이란?</h2>

<h3 id="jpql의-필요성">JPQL의 필요성</h3>

<ul>
  <li>일반적인 조회(<code class="language-plaintext highlighter-rouge">em.find()</code>, 객체그래프 탐색)가 아닌, <strong>조건이 들어간 조회</strong>가 필요하다면?</li>
  <li>모든 데이터를 조회하고 앱단에서 걸러야 하나? → NO!</li>
  <li><strong>필요한 데이터만 DB에서 불러 오는 것!</strong> (<strong>객체 중심</strong>으로 조회!) → 이 때 결국 <strong>검색 조건이 포함된 SQL</strong>이 필요 ⇒ <strong>JPQL 사용</strong> 필요!</li>
</ul>

<h3 id="jpql">JPQL</h3>

<ul>
  <li><strong>Java Persistence Query Language</strong></li>
  <li><strong>SQL을 추상화한 객체 지향 쿼리 언어</strong></li>
  <li>SQL과 문법이 유사함 → SELECT, FROM, WHERE, GROUP BY, HAVING, JOIN, …</li>
  <li>핵심은 <strong>Entity 객체를 대상으로 쿼리</strong>를 한다는 것 (SQL은 데이터베이스 테이블을 대상으로 쿼리) 
⇒ <strong>JPQL을 SQL로 번역하여 실제 DB로 보냄</strong>
    <ul>
      <li>
        <p>JPQL</p>

        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// String jpql = "select m from Member m where m.age &gt; 18";</span>
  <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> 
  			<span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span>
  					<span class="s">"select m from Member m where m.age &gt; 18"</span><span class="o">,</span> 
  					<span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">).</span><span class="na">getResultList</span><span class="o">();</span>
</code></pre></div>        </div>

        <ul>
          <li><code class="language-plaintext highlighter-rouge">.cerateQuery</code> : JPQL을 통해 query 생성</li>
          <li><code class="language-plaintext highlighter-rouge">jpql</code> : <strong>Entity 객체를 중심으로 query를 생성</strong>할 수 있음
            <ul>
              <li><code class="language-plaintext highlighter-rouge">select m</code> : 기존 SQL같은 경우 내가 조회할 항목(Col)들을 모두 작성해주어야 하지만 <strong>JPQL은 Entity 중심이기에 해당 Entity로 반환</strong>할 수 있음</li>
            </ul>
          </li>
          <li><code class="language-plaintext highlighter-rouge">Member.class</code> : 반환할 Entity 지정</li>
        </ul>
      </li>
      <li>
        <p>JPQL에 따라 실행된 SQL query</p>

        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">select</span>
  	<span class="n">m</span><span class="p">.</span><span class="n">id</span> <span class="k">as</span> <span class="n">id</span><span class="p">,</span>
  	<span class="n">m</span><span class="p">.</span><span class="n">age</span> <span class="k">as</span> <span class="n">age</span><span class="p">,</span>
  	<span class="n">m</span><span class="p">.</span><span class="n">USERNAME</span> <span class="k">as</span> <span class="n">USERNAME</span><span class="p">,</span>
  	<span class="n">m</span><span class="p">.</span><span class="n">TEAM_ID</span> <span class="k">as</span> <span class="n">TEAM_ID</span>
  <span class="k">from</span>
  	<span class="n">Member</span> <span class="n">m</span>
  <span class="k">where</span>
  	<span class="n">m</span><span class="p">.</span><span class="n">age</span><span class="o">&gt;</span><span class="mi">18</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>즉, 복잡한 쿼리를 사용할 때 발생할 수 있는 <strong>JPA와 DB의 패러다임 차이를 극복</strong>해주는 것</li>
  <li>실무에서 사용되는 <strong>복잡한 쿼리를 객체 지향적으로</strong> 짤 수 있도록 지원 → 즉, 조회 시 DB Table이 아닌 <strong>Entity 객체를 대상</strong>으로 검색</li>
  <li>JPA가 지원하는 다양한 쿼리 방법 중 하나
    <ul>
      <li>JPA가 지원하는 다양한 쿼리
        <ul>
          <li>자바 코드를 통해 <strong>JPQL을 동적으로 빌드해주는 Genterator</strong> (동적으로 query를 변경하게 할 수 있음)
            <ul>
              <li>JPA Criteria : JPA 표준 스펙. 사용이 복잡하며 실용성이 없음</li>
              <li><strong>QueryDSL</strong> : 오픈 소스. 실무에서 <strong>동적인 query를 짤 때 자주 사용하는 기술</strong></li>
            </ul>
          </li>
          <li><strong>Native SQL</strong> : JPQL을 사용해도 DB 종속적인 코드가 필요한데, 그 때 <strong>SQL 문법 그대로 사용할 수 있게끔 지원</strong>하는 것</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>JPQL은 JDBC API 직접 사용 or MyBatis, SpringJdbc와 함께 사용이 가능함</li>
  <li>SQL을 추상화하기 때문에 <strong>특정 데이터베이스 SQL에 의존X</strong></li>
</ul>

<h2 id="jpql-고급">JPQL 고급</h2>

<h3 id="경로-표현식">경로 표현식</h3>

<ul>
  <li>
    <p>“.”을 찍어 객체 그래프를 탐색하는 것</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nc">String</span> <span class="n">query</span> <span class="o">=</span> <span class="s">"select m.username 
  									 from Member m
  									 join m.team t 
  									 join m.orders o
  								where t.name = 'TeamA'"</span>
</code></pre></div>    </div>

    <ul>
      <li><strong>상태 필드</strong>
        <ul>
          <li><code class="language-plaintext highlighter-rouge">m.username</code> : 상태 필드 접근</li>
          <li>단순히 값을 저장하기 위한 필드</li>
          <li><strong>경로 탐색의 끝</strong> → 더 이상 탐색 X</li>
        </ul>
      </li>
      <li><strong>단일 값 연관 필드</strong>
        <ul>
          <li><code class="language-plaintext highlighter-rouge">m.team</code> : 단일 값 연관 필드 접근</li>
          <li><strong>대상이 Entity</strong>인 필드 → <code class="language-plaintext highlighter-rouge">@ManyToOne</code>, <code class="language-plaintext highlighter-rouge">@OneToOne</code></li>
          <li>m.team의 Team을 가져오기 위해 <strong>묵시적 내부 조인</strong> 발생 → 더 탐색 가능
            <ul>
              <li>
                <p>묵시적 조인 발생 예시</p>

                <p><code class="language-plaintext highlighter-rouge">select m.team from Member m</code></p>

                <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">select</span> <span class="n">m</span><span class="p">.</span><span class="o">*</span>
  <span class="k">from</span> <span class="n">Member</span> <span class="n">m</span>
  <span class="k">inner</span> <span class="k">join</span> <span class="n">Team</span> <span class="n">t</span> <span class="k">on</span> <span class="n">m</span><span class="p">.</span><span class="n">team_id</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">id</span>
</code></pre></div>                </div>
              </li>
            </ul>
          </li>
          <li>BUT 해당 <strong>묵시적 내부 조인은 항상 피해</strong>야 됨!</li>
        </ul>
      </li>
      <li><strong>컬렉션 값 연관 필드</strong>
        <ul>
          <li><code class="language-plaintext highlighter-rouge">m.orders</code> : 컬렉션 값 연관 필드 접근</li>
          <li>대상이 <strong>Entity들의 모음인 Collection인 필드</strong> → <code class="language-plaintext highlighter-rouge">@OneToMany</code>, <code class="language-plaintext highlighter-rouge">@ManyToMany</code></li>
          <li><strong>묵시적 내부 조인 발생</strong> → <strong>더 이상 탐색 X</strong> (<code class="language-plaintext highlighter-rouge">select t.members.username from Team t</code> → 실패)</li>
          <li>BUT! <strong>From 절에서 명시적 조인을 통해</strong> 해당 Entity에 접근한다면 탐색 가능 → <code class="language-plaintext highlighter-rouge">select m.username from Team t join t.members m</code> → 성공</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<aside>
⚠️ **묵시적 조인  vs 명시적 조인**

- **묵시적 조인**
    - `select m.team from Member m`
    - 해당 연관된 Entity의 값을 가져오기 위해 **묵시적으로 Inner Join을 실행** 하는 것 (내부 조인만 가능)
    - 말 그대로 묵시적으로 JOIN이 이루어지기에 추후 **최적화를 위한 쿼리 튜닝 시 어려워 짐** (나중에 묵시적 JOIN에서 Join이 일어났다는 것을 인지하기가 어려워 짐)
    - 묵시적 조인은 사용하면 안됨!!!! → **명시적 JOIN을 사용하자!**
- **명시적 조인**
    - `select m from Member m join m.team t`
    - **Join 키워드 직접 사용**
</aside>

<h3 id="페치-조인fetch-join">페치 조인(Fetch Join)</h3>

<ul>
  <li>개념
    <ul>
      <li>실무에서 굉장히 중요한 기능 (<strong>1+N 문제의 해결법 → 한번에 가져오기 →</strong> <strong>Fecth Join</strong>)</li>
      <li>SQL의 JOIN 종류(Inner Join, Left Join, … ) 가 아님!!</li>
      <li>JPQL에서 <strong>성능 최적화</strong>를 위해 제공하는 <strong>JPQL 전용 기능</strong>
        <ul>
          <li>연관된 Entity 나 Collection을 <strong>SQL 한 번에 함께 조회</strong>하는 기능 → query가 2번 나갈걸 1번 나가게 끔 해주는 기능</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">join fetch</code> 명령어 사용</li>
      <li>Fetch Join → <code class="language-plaintext highlighter-rouge">[ Left [OUTER] | INNER ] JOIN FETCH ___</code></li>
    </ul>
  </li>
  <li>동작
    <ul>
      <li>해당 <strong>FETCH JOIN 된 Entity까지 같이 조회</strong> (SQL 한 번에) ↔ 일반 Join은 연관된 Entity를 함께 조회하진 않음</li>
      <li>ex)
        <ul>
          <li>JPQL : <code class="language-plaintext highlighter-rouge">select m from Member m join fetch m.team</code></li>
          <li>SQL : <code class="language-plaintext highlighter-rouge">SELECT **M.*, T.*** FROM MEMBER M INNER JOIN TEAM T ON M.TEAM_ID=T.ID</code></li>
          <li>JPQL로는 team을 Join 해서 m만 조회했지만, <strong>결과적으로 t 까지 같이 조회</strong>됨</li>
          <li>결국 <strong>연관된 team이 채워진 Member Entity를 얻어</strong>낼 수 있는 것</li>
        </ul>
      </li>
      <li><strong>동작 자체는 즉시로딩(fetch = Eager)과 동일</strong>!</li>
      <li>fetch join은 내가 지금 <strong>어떤 객체그래프를 한번에 조회해올 것인지를 명시적으로 정하여 조회</strong>하는 것 → <strong>객체 그래프를 SQL 한번에 조회</strong>하는 개념</li>
      <li>추가로 <strong>지연로딩</strong> 시 발생하는 <strong>1+N 문제 해결</strong> 방법! (<strong>한번에 가져와</strong>버리기)</li>
    </ul>
  </li>
  <li>
    <p><strong>단일 연관관계 Fetch Join</strong></p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nc">String</span> <span class="n">jpql</span> <span class="o">=</span> <span class="s">"select m from Member m join fetch m.team"</span><span class="o">;</span>
  <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">members</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="n">jpql</span><span class="o">,</span> <span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
  	 <span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>
    
  <span class="k">for</span> <span class="o">(</span><span class="nc">Member</span> <span class="n">member</span> <span class="o">:</span> <span class="n">members</span><span class="o">)</span> <span class="o">{</span>
  	 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"username = "</span> <span class="o">+</span> <span class="n">member</span><span class="o">.</span><span class="na">getUsername</span><span class="o">()</span> <span class="o">+</span> <span class="s">", "</span> 
  		<span class="o">+</span> <span class="s">"teamName = "</span> <span class="o">+</span> <span class="n">member</span><span class="o">.</span><span class="na">getTeam</span><span class="o">().</span><span class="na">name</span><span class="o">());</span>
  <span class="o">}</span>
</code></pre></div>    </div>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">join fetch</code> : Fetch Join 사용 → 한번에 가져와버리기
        <ul>
          <li>만약 <strong>Team이 없는 Member를 포함해서 조회</strong>하고 싶다면 <code class="language-plaintext highlighter-rouge">left join fetch</code> 를 통해 <strong>Outer Fetch Join 을 적용</strong>하면 됨</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">member.getTeam().name()</code> : 연관객체 접근
        <ul>
          <li>Lazy로딩 상태이기에 <strong>Fetch Join을 사용하지 않았다면</strong> Proxy 객체의 초기화로 인해 <strong>1+N 문제가 발생!</strong></li>
          <li>Fetch Join을 사용했기에 애초에 Proxy 객체가 아닌 <strong>실제 Entity로 채워져 있어 query가 1개만 발생함</strong>! → <strong>1+N 문제 해결</strong></li>
          <li>즉, 애초에 Lazy로딩이 아닌 <strong>즉시로딩처럼 접근</strong>하는 것</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>컬렉션 연관관계 Fetch Join</strong></p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nc">String</span> <span class="n">jpql</span> <span class="o">=</span> <span class="s">"select t from Team t join fetch t.members"</span><span class="o">;</span>
  <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Team</span><span class="o">&gt;</span> <span class="n">teams</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="n">jpql</span><span class="o">,</span> <span class="nc">Team</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
  	 <span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>
    
  <span class="k">for</span><span class="o">(</span><span class="nc">Team</span> <span class="n">team</span> <span class="o">:</span> <span class="n">teams</span><span class="o">)</span> <span class="o">{</span>
  	 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"teamname = "</span> <span class="o">+</span> <span class="n">team</span><span class="o">.</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">", team = "</span> <span class="o">+</span> <span class="n">team</span><span class="o">);</span>
  	 <span class="k">for</span> <span class="o">(</span><span class="nc">Member</span> <span class="n">member</span> <span class="o">:</span> <span class="n">team</span><span class="o">.</span><span class="na">getMembers</span><span class="o">())</span> <span class="o">{</span>
  		 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="err">“</span><span class="o">-&gt;</span> <span class="n">username</span> <span class="o">=</span> <span class="s">" + member.getUsername()+ "</span><span class="o">,</span> <span class="n">member</span> <span class="o">=</span> <span class="err">"</span> <span class="o">+</span> <span class="n">member</span><span class="o">);</span>
  	 <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div>    </div>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">join fetch</code> : Fetch Join 사용 → 한번에 가져와버리기
        <ul>
          <li>만약 Members가 없는 Team을 포함해서 조회하고 싶다면 <code class="language-plaintext highlighter-rouge">left join fetch</code> 를 통해 <strong>Outer Fetch Join</strong> 을 적용하면 됨</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">member.getUsername()</code> : 연관객체 접근
        <ul>
          <li>Lazy로딩 상태이기에 <strong>Fetch Join을 사용하지 않았다면</strong> Proxy 객체의 초기화로 인해 <strong>1+N 문제</strong>가 발생!</li>
          <li>Fetch Join을 사용했기에 애초에 Proxy 객체가 아닌 <strong>실제 Entity로 채워</strong>져 있어 query가 1개만 발생함! → 1+N 문제 해결</li>
          <li>즉, 애초에 <strong>Lazy로딩이 아닌 즉시로딩처럼 접근</strong>하는 것 → 페치 조인으로 팀과 회원을 함께 조회해서 지연 로딩 발생 안함</li>
        </ul>
      </li>
      <li><strong>여기서 주의 점</strong>
        <ul>
          <li>만약 TeamA에 속해 있는 Member가 2명이다? → 위의 fetch join으로 조회 시 TeamA가 두번 조회 됨.</li>
          <li>
            <p>이는 <strong>일대다 join 의 특성 상</strong> 어쩔 수 없는 것 → <strong>App단에서 처리</strong>가 필요함</p>

            <p><img src="/images/posts/post-220828/Untitled.png" alt="Untitled" /></p>

            <ul>
              <li>Group By가 아니기 때문에 Member 개수에 맞게 TeamA가 mapping되어 2개로 조회가 되는 것</li>
              <li>이는 <strong>DISTINCT로 해결</strong> 가능</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>일대다 Fect Join과 DISTINCT</strong>
    <ul>
      <li>JPQL <strong>DISTINCT</strong> 로 <strong>일대다 FETCH JOIN 시의 중복 문제를 해결</strong>할 수 있음</li>
      <li>SQL의 DISTINCT : <strong>완벽히 일치하는 중복 데이터</strong>를 제거</li>
      <li><strong>JPQL의 DISTINCT</strong>
        <ul>
          <li>기본적으로 SQL에 DISTINCT 추가</li>
          <li>
            <p>APP단에서 <strong>Entity 중복 제거 (식별자를 통해)</strong></p>

            <p><img src="JPQL%20%E1%84%80%E1%85%A9%E1%84%80%E1%85%B3%E1%86%B8%2066142436e6da4513919ae6966e6a8509/Untitled%201.png" alt="Untitled" /></p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>[중요]</strong> <strong>페치 조인(Fetch Join)의 한계</strong>
    <ul>
      <li>페치 조인은 항상 그 특징과 주의점(한계)을 잘 알고 사용해야 됨</li>
      <li><strong>Fetch Join 의 한계</strong>
        <ul>
          <li><strong>Fetch Join의 대상에는 별칭을 줄 수 없음</strong> → <code class="language-plaintext highlighter-rouge">join fetch t.members m</code> X (hibernate 구현체에선 사용 가능하나 예기치 못한 버그가 발생할 수 있으므로 가급적이면 자제하는 것이 좋음!)</li>
          <li><strong>둘 이상의 컬렉션은 Fetch Join 불가능!</strong> → 가능은 하나 가급적 사용 X  (일대다 도 데이터가 뻥튀기가 되는데 일대다에 또 일대다 를 적용할 시 데이터가 예기치 못하게 수없이 뻥튀기가 될 수 있음, 데이터 매핑도 제대로 안되는 경우가 있음)</li>
          <li><strong>컬렉션을 패치 조인하면 페이징 API(setFirstResult, setMaxResults)를 사용 못함</strong>
            <ul>
              <li>일대일, 다대일 같은 단일 값 연관 필드 FETCH JOIN은 데이터 뻥튀기가 되지 않기 때문에 페이징 가능</li>
              <li><strong>일대다 같은 컬렉션 값 연관 필드 FETCH JOIN은 데이터 뻥튀기가 되기 때문에</strong> 페이징 불가능 → <strong>페이징은 SQL단에서 이루어지는 것</strong>이기에 JPQL DISTINCT로도 막을 수 없음 (JPQL DISTINCT는 App단에서 실행됨) [hibernate 구현체는 가능은 하나 메모리 단에서 실행되기에 메모리 초과가 발생함]</li>
            </ul>
          </li>
        </ul>
      </li>
      <li><strong>컬렉션 Fetch Join 페이징 해결법</strong>
        <ul>
          <li>일대다 FETCH JOIN을 <strong>다대일 FETCH JOIN으로 조회</strong>한 후 페이징 : <code class="language-plaintext highlighter-rouge">select t from Team t join fetch t.members;</code> → <code class="language-plaintext highlighter-rouge">select m from Member m join fetch m.team;</code></li>
          <li><strong>[중요] BATCH 조회</strong>
            <ul>
              <li><strong>FETCH JOIN 없이 조회</strong>하여 페이징 하는데 <strong>LAZY로딩의 Entity들은 BATCH_SIZE를 이용하여 조회하여 최적화</strong>하기</li>
              <li><strong>필요로 하는 Entity를 한번의 in query SQL로 묶어서 가져</strong>오는 것
                <ul>
                  <li>지연로딩 시의 1+N 문제에서 <strong>N에 해당하는 것들을 한번에 in query로 가져</strong>옴 → <code class="language-plaintext highlighter-rouge">where m.team_id in (?,?,?, … )</code></li>
                </ul>
              </li>
              <li><code class="language-plaintext highlighter-rouge">@BatchSize</code> 로 Entity 단위로 적용 하거나 <strong>Global Setting</strong>으로 전체 Entity에 적용 가능</li>
              <li>
                <p><code class="language-plaintext highlighter-rouge">@BatchSize</code> (Entity 속 <code class="language-plaintext highlighter-rouge">@OneToMay</code> 관계에 적용)</p>

                <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// Team Entity</span>
  <span class="nd">@BatchSize</span><span class="o">(</span><span class="n">size</span> <span class="o">=</span> <span class="mi">100</span><span class="o">)</span>
  <span class="nd">@OneToMany</span><span class="o">(</span><span class="n">mappedBy</span> <span class="o">=</span> <span class="s">"team"</span><span class="o">)</span>
  <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">members</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
</code></pre></div>                </div>

                <ul>
                  <li><code class="language-plaintext highlighter-rouge">@BatchSize(size = 100)</code> : 해당 관계의 Entity를 Lazy로딩으로 가져올 때 최대 100개를 한번에 가져온다는 뜻 (<strong>in query를 사용</strong>하여)</li>
                </ul>
              </li>
              <li><strong>Gloabl Setting</strong>
                <ul>
                  <li>property.xml 에서 JPA 설정</li>
                  <li><code class="language-plaintext highlighter-rouge">&lt;property name=”hibernate.default_batch_fetch_size” value=”100”/&gt;</code></li>
                  <li><strong>모든 일대다 관계에서 Lazy 로딩 조회 시 in query 로 한번에 가져오겠다</strong>는 설정</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="다형성-쿼리">다형성 쿼리</h3>

<ul>
  <li><strong>TYPE</strong>
    <ul>
      <li><strong>조회 대상을 특정 자식으로 한정</strong></li>
      <li><code class="language-plaintext highlighter-rouge">type(_)</code></li>
      <li>
        <p>예시) 부모 Entity Item 의 자식 중 Book, Movie 만 조회</p>

        <p><code class="language-plaintext highlighter-rouge">select i from Item i where type(i) in (Book, Movie)</code> →</p>

        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">select</span> <span class="n">i</span> <span class="k">from</span> <span class="n">Item</span> <span class="n">i</span>
  <span class="k">where</span> <span class="n">i</span><span class="p">.</span><span class="n">DTYPE</span> <span class="k">in</span> <span class="p">(</span><span class="s1">'B'</span><span class="p">,</span><span class="s1">'M'</span><span class="p">)</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong>TREAT</strong>
    <ul>
      <li>Java의 <strong>타입 캐스팅</strong>과 유사 (업,다운 캐스팅)</li>
      <li>상속 구조에서 <strong>부모 타입을 특정 자식 타입으로</strong> 다룰 때 사용 → ex) 부모 타입을 자식 타입으로 바꿔 필드 탐색을 진행할 때</li>
      <li>FROM, WHERE, SELECT(hibernate 구현체) 에서 사용</li>
      <li><code class="language-plaintext highlighter-rouge">treat( 부모 as 자식 )</code></li>
      <li>
        <p>예시) 부모로 조회하는데 조건에 자식의 필드를 사용하고 싶을 때</p>

        <p><code class="language-plaintext highlighter-rouge">select i from Item i where treat(i as Book).auter = kim</code> →</p>

        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">select</span> <span class="n">i</span><span class="p">.</span><span class="o">*</span> <span class="k">from</span> <span class="n">Item</span> <span class="n">i</span>
  <span class="k">where</span> <span class="n">i</span><span class="p">.</span><span class="n">DTYPE</span> <span class="o">=</span> <span class="err">‘</span><span class="n">B</span><span class="err">’</span> <span class="k">and</span> <span class="n">i</span><span class="p">.</span><span class="n">auther</span> <span class="o">=</span> <span class="err">‘</span><span class="n">kim</span><span class="err">’</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h3 id="엔티티-직접-사용">엔티티 직접 사용</h3>

<ul>
  <li>데이터가 들어갈 자리에 엔티티를 직접 넣게 될 때의 상황</li>
  <li>
    <p><strong>엔티티를 직접 사용</strong>하게 되면 <strong>기본 키(PK)값이 들어가게 됨</strong></p>

    <p>JPQL : <code class="language-plaintext highlighter-rouge">select count(m) from Member m</code> → SQL : <code class="language-plaintext highlighter-rouge">select count(m.id) as cnt from Member m</code> [<code class="language-plaintext highlighter-rouge">count(m) → count(m.id)</code>]</p>
  </li>
  <li><strong>기본 키(PK)</strong>
    <ul>
      <li>
        <p><strong>엔티티를 파라미터로 전달</strong>하는 경우</p>

        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">String</span> <span class="n">jpql</span> <span class="o">=</span> <span class="err">“</span><span class="k">select</span> <span class="n">m</span> <span class="k">from</span> <span class="n">Member</span> <span class="n">m</span> <span class="k">where</span> <span class="n">m</span> <span class="o">=</span> <span class="p">:</span><span class="n">member</span><span class="err">”</span><span class="p">;</span>
  <span class="n">List</span> <span class="n">resultList</span> <span class="o">=</span> <span class="n">em</span><span class="p">.</span><span class="n">createQuery</span><span class="p">(</span><span class="n">jpql</span><span class="p">)</span>
  											 <span class="p">.</span><span class="n">setParameter</span><span class="p">(</span><span class="nv">"member"</span><span class="p">,</span> <span class="n">member</span><span class="p">)</span>
  											 <span class="p">.</span><span class="n">getResultList</span><span class="p">();</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>식별자를 직접 전달하는 경우</p>

        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">String</span> <span class="n">jpql</span> <span class="o">=</span> <span class="err">“</span><span class="k">select</span> <span class="n">m</span> <span class="k">from</span> <span class="n">Member</span> <span class="n">m</span> <span class="k">where</span> <span class="n">m</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="p">:</span><span class="n">memberId</span><span class="err">”</span><span class="p">;</span>
  <span class="n">List</span> <span class="n">resultList</span> <span class="o">=</span> <span class="n">em</span><span class="p">.</span><span class="n">createQuery</span><span class="p">(</span><span class="n">jpql</span><span class="p">)</span>
  											 <span class="p">.</span><span class="n">setParameter</span><span class="p">(</span><span class="nv">"memberId"</span><span class="p">,</span> <span class="n">memberId</span><span class="p">)</span>
  											 <span class="p">.</span><span class="n">getResultList</span><span class="p">();</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>결과 SQL</p>

        <p><code class="language-plaintext highlighter-rouge">select m.* from Member m where m.id=?</code></p>
      </li>
      <li>
        <p>중요한 것은 엔티티를 파라미터로 전달하는 경우 where m.id 가 아닌 그냥 m 임 → 즉, <strong>엔티티를 직접 사용하면 조건 자체도 엔티티로 판별</strong>해야됨 (SQL은 항상 식별자로 판단됨)</p>
      </li>
    </ul>
  </li>
  <li><strong>외래 키(FK)</strong>
    <ul>
      <li>외래 키도 기본 키 사용법과 동일</li>
      <li>엔티티를 파라미터로 전달 : <code class="language-plaintext highlighter-rouge">where m.team = :team</code> , <code class="language-plaintext highlighter-rouge">.setParameter("team", team)</code></li>
      <li>식별자를 직접 전달 : <code class="language-plaintext highlighter-rouge">where m.team.id = :teamId</code> , <code class="language-plaintext highlighter-rouge">.setParameter("teamId", teamId)</code></li>
      <li>
        <p>실행된 SQL</p>

        <p><code class="language-plaintext highlighter-rouge">select m.* from Member m where m.team_id=?</code></p>
      </li>
    </ul>
  </li>
</ul>

<h3 id="named-쿼리">Named 쿼리</h3>

<ul>
  <li><strong>미리 query를 정의</strong>해서 이름을 부여해두고 <strong>사용하는 JPQL</strong></li>
  <li><strong>정적 쿼리</strong> (동적 쿼리 불가능)</li>
  <li>어노테이션으로 정의 or XML에 정의 해서 사용</li>
  <li><strong>Application 로딩 시점에 초기화 후 재사용 가능</strong> → SQL로 파싱한 후부터는 다시 파싱하지 않고 재사용 (성능 최적화)</li>
  <li><strong>[중요] Application 로딩 시점에 쿼리를 검증</strong> → App이 돌아가는 와중에 오류 뜰 일이 없음</li>
  <li>
    <p>정의</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nd">@Entity</span>
  <span class="nd">@NamedQuery</span><span class="o">(</span>
  		 <span class="n">name</span><span class="o">=</span><span class="s">"Member.findByUsername"</span><span class="o">,</span>
  		 <span class="n">query</span><span class="o">=</span><span class="s">"select m from Member m where m.username = :username"</span><span class="o">)</span>
  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
  		 <span class="o">...</span>
  <span class="o">}</span>
</code></pre></div>    </div>

    <ul>
      <li>어노테이션 기반으로 정의.</li>
      <li>실행될 query와 사용될 이름을 정의</li>
      <li>query 속에는 파라미터 설정도 가능</li>
    </ul>
  </li>
  <li>
    <p>사용</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">em</span><span class="o">.</span><span class="na">createNamedQuery</span><span class="o">(</span><span class="s">"Member.findByUsername"</span><span class="o">,</span> <span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
  			<span class="o">.</span><span class="na">setParameter</span><span class="o">(</span><span class="s">"username"</span><span class="o">,</span> <span class="s">"park"</span><span class="o">)</span>
  			<span class="o">.</span><span class="na">getSingleResult</span><span class="o">();</span>
</code></pre></div>    </div>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">em.createNamedQuery()</code> : 정의된 namedQuery를 불러오는 함수. 정의된 이름으로 query를 불러옴</li>
      <li>그 이후로는 기존 createQuery와 사용법 동일</li>
    </ul>
  </li>
  <li><strong>[중요]</strong> <code class="language-plaintext highlighter-rouge">@NamedQuery</code> 는 <strong>Spring Data JPA 에서 <code class="language-plaintext highlighter-rouge">@Query</code> 로 사용</strong>됨 !! (실무에선 <code class="language-plaintext highlighter-rouge">@Query</code>가 굉장히 많이 사용됨 → <strong>빌드 시점에 SQL 파싱을 하기 때문에 오류를 빌드시점에 찾아낼 수 있고 또한 재사용이 가능</strong>하기에!)</li>
</ul>

<h3 id="벌크-연산">벌크 연산</h3>

<ul>
  <li><strong>한번에 여러 개의 Entity를 수정하고 이를 DB에 반영</strong>하고 싶다면?
    <ul>
      <li>기존의 수정 방법인 <strong>변경 감지</strong>를 이용하여 진행한다면 <strong>각 Entity별로 query가 나가기 때문에 비효율적!</strong></li>
      <li>이럴 때 사용하는 것이 <strong>벌크 연산</strong></li>
    </ul>
  </li>
  <li><strong>벌크 연산</strong> : <strong>쿼리 한번으로 여러 Table Row(Entity)를 변경</strong></li>
  <li><code class="language-plaintext highlighter-rouge">executeUpdate()</code>
    <ul>
      <li>표준으로 UPDATE, DELETE 지원</li>
      <li>hibernate 구현체는 INSERT 까지 지원</li>
      <li><strong>반환 값은 영향받은 엔티티의 수</strong> (int)</li>
    </ul>
  </li>
  <li>
    <p>사용</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nc">String</span> <span class="n">qlString</span> <span class="o">=</span> 
  		 <span class="s">"update Product p "</span> <span class="o">+</span>
  		 <span class="s">"set p.price = p.price * 1.1 "</span> <span class="o">+</span>
  		 <span class="s">"where p.stockAmount &lt; :stockAmount"</span><span class="o">;</span>
    
  <span class="kt">int</span> <span class="n">resultCount</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="n">qlString</span><span class="o">)</span>
  											 <span class="o">.</span><span class="na">setParameter</span><span class="o">(</span><span class="s">"stockAmount"</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
  											 <span class="o">.</span><span class="na">executeUpdate</span><span class="o">();</span>
</code></pre></div>    </div>

    <ul>
      <li>기존에 사용했던 JPQL과 비슷하지만 마지막에 <code class="language-plaintext highlighter-rouge">.executeUpdate()</code> 로 <strong>벌크 연산을 수행</strong>하는 것이 다름</li>
      <li>해당 벌크 연산을 통해 10개 이하의 모든 상품들은 가격이 10프로 상승하게 됨</li>
      <li>만약 해당 조건에 맞는 상품들이 100개 라면 기<strong>존의 변경감지를 사용했을 때는 100개의 쿼리</strong>가 나가지만, <strong>벌크 연산을 통해 진행하면 1개의 쿼리만</strong>이 나감 → 성능 최적화 Good!!</li>
    </ul>
  </li>
  <li><strong>벌크 연산 사용 주의점</strong>
    <ul>
      <li>벌크 연산은 <strong>영속성 컨텍스트를 무시하고 DB에 직접 쿼리를 날리는 방법</strong> 이므로 항상 주의 해야됨 ( JPA는 영속성 컨텍스트와 함께 동작하는 애이므로 )</li>
      <li>해결
        <ul>
          <li><strong>벌크 연산을 먼저 실행</strong>하는 방법
            <ul>
              <li>영속성 컨텍스트 작업을 진행하지 않고 그냥 <strong>가장 먼저 벌크 연산을 실행</strong>해서 영속성 컨텍스트에 영향을 주지 않는 방법</li>
            </ul>
          </li>
          <li><strong>벌크 연산 수행 후 영속성 컨텍스트를 초기화(<code class="language-plaintext highlighter-rouge">em.clear()</code>)</strong>하는 방법
            <ul>
              <li>벌크 연산도 JPQL로 동작하기에 <code class="language-plaintext highlighter-rouge">flush()</code>는 됨</li>
              <li>하지만, 초기화는 되지 않기에 따로 <strong>영속성 컨텍스트를 초기화하는 것이 중요</strong></li>
              <li><strong>초기화의 필요성</strong> : 영속성 컨텍스트를 초기화하지 않으면 벌크 연산 이후에 조회한 Entity가 만약 벌크 연산 이전에 조회되어 영속성 컨텍스트에 있다고 하면, 영속성 컨텍스트가 초기화되지 않았기 때문에 <strong>변경 이전의 Entity로 반영이 됨. (1차 캐시)</strong></li>
              <li>그러므로 <strong>벌크연산이 반영된 Entity의 결과로 조회하려면 영속성 컨텍스트는 초기화가 필수!</strong></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>

    <aside>
  ⚠️ **[참고] JPQL이 flush만 하고 초기화하지 않는 데 벌크 연산은 초기화를 진행해야되는 이유**
    
  - **JPQL : flush 자동 O , clear 필수 X**
  기본 JPQL은 사실 조회로직이 대다수 이며 **JPQL을 통해서 조회 시 항상 바로 SQL문이 실행되어 바로 DB에서 가져오**기 때문에 그 이전의 영속성 컨텍스트를 통해 변경되거나 저장된 애들에 대한 **반영이 필요하기에 flush가 동작**함. 즉, 조회 로직만이 수행되기 때문에 초기화가 따로 필요 없는 것 (**이미 영속성 컨텍스트에 반영된 내용**이므로)
  - **벌크 연산 : flush 자동 O, claer 필수 O**
  하지만, **벌크 연산같은 경우 UPDATE 쿼리가 나감**. 이때 UPDATE 로직은 **영속성 컨텍스트를 거치지 않고 바로 DB로 SQL을 날리기 때문에 변경내용이 영속성 컨텍스트에 반영되지 않음**. 이에 따라 벌크 연산 이후 Entity를 조회할 시 **이전의 영속성 컨텍스트에 남아 있는 (변경이 반영되지 않은) Entity를 가져오게 됨**. 그러므로 벌크 연산 시 항상 **초기화가 필요**
  * JPQL을 통해 INSERT,UPDATE,DELETE 시 초기화 필수!
  </aside>
  </li>
  <li><strong>[참고]</strong> 해당 <strong>벌크 연산</strong>은 <strong>Spring Data JPA 에선 <code class="language-plaintext highlighter-rouge">@Modifiying</code> 으로 편리하게 사용</strong> 가능 (원리가 동일!)</li>
</ul>
:ET