I"E<h1 id="고급-매핑">고급 매핑</h1>

<h2 id="상속관계-매핑">상속관계 매핑</h2>

<h3 id="상속관계-매핑-1">상속관계 매핑</h3>

<ul>
  <li>객체는 상속관계가 존재</li>
  <li>But <strong>관계형 데이터베이스</strong>는 객체에서 사용되는 <strong>상속관계가 사실 없다고 볼 수 있음</strong></li>
  <li>하지만 객체 상속과 유사한 개념이 <strong>DB에선 슈퍼타입 서브타입 관계라는 모델링 기법</strong>(논리 모델)으로 존재</li>
</ul>

<p><img src="%E1%84%80%E1%85%A9%E1%84%80%E1%85%B3%E1%86%B8%20%E1%84%86%E1%85%A2%E1%84%91%E1%85%B5%E1%86%BC%20f155061fd1164b2a84b5e27794bf65ca/Untitled.png" alt="Untitled" /></p>

<ul>
  <li>즉, <strong>상속관계 매핑</strong>이란 <strong>객체의 상속 구조와 DB의 슈퍼타입 서브타입 관계를 매핑</strong>하는 것</li>
  <li>상속관계 매핑 방법
    <ul>
      <li><strong>DB의 슈퍼타입 서브타입 논리 모델을 실제 물리 모델로 구현</strong>하는 방법
        <ol>
          <li><strong>각각</strong> 테이블로 변환 → <strong>JOIN 전략</strong> (정석적으로 사용되는 전략)</li>
          <li><strong>통합</strong> 테이블로 변환 → <strong>SINGLE TABLE 전략</strong></li>
          <li><strong>서브타입</strong> 테이블로 변환 → <strong>TABLE PER CLASS 전략</strong></li>
        </ol>
      </li>
      <li><strong>[중요] 객체 입장에서는 항상 똑같은 상속관계!</strong></li>
    </ul>
  </li>
  <li>사용 방법
    <ul>
      <li>
        <p>상위 Class → Item Entity</p>

        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nd">@Entity</span>
  <span class="nd">@Inheritance</span><span class="o">(</span><span class="n">strategy</span> <span class="o">=</span> <span class="o">...</span> <span class="o">)</span>
  <span class="nd">@DiscriminatorColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"DTYPE"</span><span class="o">)</span>
  <span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Item</span><span class="o">{</span> <span class="c1">// 독단적으로 사용할 일이 없으므로 abstract로 설정</span>
      <span class="nd">@Id</span>
      <span class="nd">@GeneratedValue</span>
      <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>
  		<span class="o">...</span>
  <span class="o">}</span> 
</code></pre></div>        </div>

        <ul>
          <li><code class="language-plaintext highlighter-rouge">@Inheritance(strategy = InheritanceType.XXX)</code>
            <ul>
              <li><strong>상속 전략</strong> 선택</li>
              <li><strong>JOINED</strong> : 조인 전략</li>
              <li><strong>SINGLE_TABLE</strong>: 단일 테이블 전략</li>
              <li><strong>TABLE_PER_CLASS</strong>: 구현 클래스마다 테이블 전략</li>
              <li>해당 <strong>어노테이션 없이</strong> 상속을 진행하면 <strong>자동으로 SINGLE_TABLE로 설정</strong>됨</li>
            </ul>
          </li>
          <li><code class="language-plaintext highlighter-rouge">@DiscriminatorColumn(name = … )</code>
            <ul>
              <li>각각의 <strong>서브타입을 구분하는 Column</strong> 명 지정</li>
              <li>기본값 : <strong>DTYPE</strong></li>
              <li>해당 어노테이션이 없다면 구분하는 Column 생성 X (Single Table에선 자동으로 DTYPE으로 설정됨)</li>
              <li>필수적인 항목은 아니지만, 있어야지 운영하기에 좋음 → Item이 저장될 때 어떤 하위 Entity로 저장되는지 알 수 있으므로 → 즉 <strong>하위 Entity 없이 Item Entity하나로도 할 수 있는 것들이 많아짐</strong></li>
              <li>JOIN 전략에선 필수 X</li>
              <li>SINGLE TABLE 전략에선 필수! → 고로 SINGLE TABLE에 해당 어노테이션을 달지 않아도 자동으로 DTYPE이 설정됨</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        <p>하위 Class → Ablum Entity</p>

        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nd">@Entity</span>
  <span class="nd">@DiscriminatorValue</span><span class="o">(</span><span class="s">"A"</span><span class="o">)</span>
  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Album</span> <span class="kd">extends</span> <span class="nc">Item</span><span class="o">{</span>
      <span class="kd">private</span> <span class="nc">String</span> <span class="n">artist</span><span class="o">;</span>
  <span class="o">}</span>
</code></pre></div>        </div>

        <ul>
          <li><code class="language-plaintext highlighter-rouge">extends Item</code> : Item 상속</li>
          <li><code class="language-plaintext highlighter-rouge">@DiscriminatorValue( … )</code>
            <ul>
              <li>슈퍼타입의 구분 Column에 <strong>어떤 값으로 저장될지</strong> 설정</li>
              <li>즉, <strong>어떤값으로 구분될 것인지</strong>를 설정</li>
              <li>기본값 : Entity 명</li>
            </ul>
          </li>
          <li>다른 하위 Class 인 Moive, Book Entity도 동일</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<aside>
⚠️ **관계에 따른 객체와 관계형 데이터베이스의 입장**

- **연관관계 매핑** : DB입장에선 동일(TABLE은 항상 동일)! 객체 입장에선 방향성(단,양), 연관관계의 주인을 어떻게 설정하느냐 등에 따라 달라짐!
- **상속관계 매핑** : 객체 입장에선 동일(상속관계는 항상 동일)! DB 입장에선 어떤 전략을 세우냐에 따라 달라짐! → 즉, 상속전략을 어떻게 바꾸든 간에 App단(JAVA)에서 상속을 사용하는 코드는 수정할 필요가 없음! (항상 동일하기 때문)
</aside>

<h3 id="join-전략">JOIN 전략</h3>

<ul>
  <li>
    <p>개념</p>

    <p><img src="%E1%84%80%E1%85%A9%E1%84%80%E1%85%B3%E1%86%B8%20%E1%84%86%E1%85%A2%E1%84%91%E1%85%B5%E1%86%BC%20f155061fd1164b2a84b5e27794bf65ca/Untitled%201.png" alt="Untitled" /></p>

    <ul>
      <li>ITEM 이라는 Table(<strong>상위 Table</strong>) 을 만들고 <strong>각각의 하위 Table</strong> (ALBUM, MOVIE, BOOK)을 만들어 나눈 다음에 <strong>하위 Table을 가져올 때 JOIN으로 구성</strong>하는 것</li>
      <li>예를 들어 ALBUM을 설정 한다면 앨범의 NAME, PRICE는 ITEM에 들어오게 되고 ARTIST는 ALBUM에 들어가게 되는 것</li>
      <li><strong>저장</strong> 시 INSERT query는 ITEM 1번, ALBUM 1번, <strong>총 2번</strong> 들어가게 됨</li>
      <li><strong>조회</strong> 시 <strong>JOIN을 통해</strong> ITEM과 ALBUM을 동시에 가져오게 됨 → JOIN 전략</li>
      <li>각각의 하위 Table을 구분하기 위해 ITEM에서 DTYPE을 사용하게 됨</li>
      <li>특징 : <strong>하위 Table은 상위 Table과 동일한 id값</strong>을 가지게됨 → <strong>하위 Table에서의 id값은 PK이자 FK!</strong></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">@Inheritance(strategy = InheritanceType.JOINED)</code>
    <ul>
      <li>저장
        <ul>
          <li><code class="language-plaintext highlighter-rouge">em.persist(album)</code> 를 통해 하위 Entity를 저장</li>
          <li><strong>저장 시 Item 1개, Album 1개가 저장</strong>됨 (INSERT query 2개)</li>
          <li>Item에는 해당 속성에 맞는 값이 저장됨</li>
          <li>Album에는 해당 Item과 동일한 Id값(PK이자 FK)를 갖게 됨</li>
        </ul>
      </li>
      <li>조회
        <ul>
          <li><code class="language-plaintext highlighter-rouge">em.find(Album.class, album.getId())</code> 를 통해 하위 Entity를 조회</li>
          <li><strong>조회 시 Album에 Item을 JOIN</strong> 하여 가져오게 됨 (INNER JOIN query 1개)</li>
          <li>JOIN을 통해 해당 album 객체를 상속관계로써 정상적으로 사용할 수 있음</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>장점
    <ul>
      <li><strong>테이블 정규화</strong> (객체 그래프와 유사 → 유연성, 활용도가 높음)</li>
      <li>외래 키 참조 무결성 제약조건 활용 가능! → 상위 Class를 보고자할 때, 하위 Class를 참고해야되는 것이 아닌 <strong>상위 Class의 key만으로도 파악이 가능!</strong></li>
      <li>저장 공간 효율화</li>
    </ul>
  </li>
  <li>단점
    <ul>
      <li>성능 저하 ← JOIN</li>
      <li>조회 쿼리 복잡 ← JOIN</li>
      <li>데이터 저장시 INSERT SQL 2번 호출 ← JOIN</li>
      <li>그렇게 큰 단점은 아님! (단일테이블에 비해서의 단점)</li>
    </ul>
  </li>
</ul>

<h3 id="single-table-전략">SINGLE TABLE 전략</h3>

<ul>
  <li>
    <p>개념</p>

    <p><img src="%E1%84%80%E1%85%A9%E1%84%80%E1%85%B3%E1%86%B8%20%E1%84%86%E1%85%A2%E1%84%91%E1%85%B5%E1%86%BC%20f155061fd1164b2a84b5e27794bf65ca/Untitled%202.png" alt="Untitled" /></p>

    <ul>
      <li>DB의 슈퍼타입 서브타입 논리 모델을 <strong>슈퍼타입의 한 테이블로 표현</strong>한 것 → <strong>서브타입의 Table은 존재X</strong></li>
      <li>각각의 서브타입의 모든 Column을 슈퍼타입 Table에 다 때려 박는 것 → 해당되지 않는 서브타입의 속성에 대해선 <strong>null 발생</strong></li>
      <li><strong>DTYPE을 통해 각 서브타입을 구분</strong> (DTYPE이 필수! → 고로 <code class="language-plaintext highlighter-rouge">@DiscriminatorColumn</code>이 없어도 자동으로 DTYPE이 생성됨 )</li>
      <li>성능측면에서 가장 우수 (JOIN없이 하나의 테이블을 그대로 가져오니)</li>
      <li><strong>단순한 모델링일 경우 자주 사용</strong>됨</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">@Inheritance(strategy = InheritanceType.SINGLE_TABLE)</code>
    <ul>
      <li>저장
        <ul>
          <li><code class="language-plaintext highlighter-rouge">em.persist(album)</code> 를 통해 하위 Entity를 저장</li>
          <li><strong>저장 시 Item 1개가 저장</strong>됨 (INSERT query 1개)</li>
          <li>Item에 album에서 지정된 값들이 저장됨</li>
          <li><strong>나머지 하위 Entity들에 대한 값들은 null로 설정</strong>됨</li>
        </ul>
      </li>
      <li>조회
        <ul>
          <li><code class="language-plaintext highlighter-rouge">em.find(Album.class, album.getId())</code> 를 통해 하위 Entity를 조회</li>
          <li><strong>조회 시 DTYPE을 통해 구분하여 Item의 테이블 하나만 조회</strong>함 (일반 SELECT query 1개) → 성능 UP</li>
          <li><strong>Item 테이블의 기본 속성과 album 속성을 빼내서 Album Entity를 만들어줌</strong> (<strong>DTYPE</strong> 을 통해서)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>장점
    <ul>
      <li>JOIN을 하지 않으므로 조회 성능이 빠름</li>
      <li>조회 query가 단순</li>
    </ul>
  </li>
  <li>단점
    <ul>
      <li>자식 Entity 가 매핑한 Col은 모두 <strong>null 허용</strong> → DB 입장에서 큰 단점</li>
      <li>모든 것을 저장하기에 테이블이 커져 상황에 따라 조회 성능이 오히려 저하될 수 있다</li>
    </ul>
  </li>
</ul>

<h3 id="table-per-class-전략">TABLE PER CLASS 전략</h3>

<ul>
  <li>
    <p>개념</p>

    <p><img src="%E1%84%80%E1%85%A9%E1%84%80%E1%85%B3%E1%86%B8%20%E1%84%86%E1%85%A2%E1%84%91%E1%85%B5%E1%86%BC%20f155061fd1164b2a84b5e27794bf65ca/Untitled%203.png" alt="Untitled" /></p>

    <ul>
      <li><strong>구현 클래스마다 테이블을 만드는 전략</strong></li>
      <li>ITEM TABLE은 만들지 않고 <strong>각각의 서브타입에 해당되는 TABLE들만 생성</strong></li>
      <li>각각의 TABLE이 ITEM TABLE의 모든 COL을 가지고 있는 것</li>
      <li>하지만 권장되지 않는 전략 → 부모 Class 로 조회 시 해당 모든 하위 Class를 다 뒤져서 가져옴 <strong>(UNION query 발생!)</strong></li>
      <li>해당 전략은 DB,ORM 두 입장 모두에서 비효율적인 전략 → 쓰지말자</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)</code>
    <ul>
      <li>저장
        <ul>
          <li><code class="language-plaintext highlighter-rouge">em.persist(album)</code> 를 통해 하위 Entity를 저장</li>
          <li><strong>저장 시 Item 은 저장되지 않음</strong></li>
          <li><strong>해당 Album Entity만 저장</strong>되게 됨 → Item의 속성 + album 속성을 가진 채로</li>
        </ul>
      </li>
      <li>조회
        <ul>
          <li><code class="language-plaintext highlighter-rouge">em.find(Album.class, album.getId())</code> 를 통해 하위 Entity를 조회</li>
          <li><strong>조회 시 Album 테이블 하나만 조회</strong>함 (일반 SELECT query 1개)</li>
        </ul>
      </li>
      <li>즉, Item Table은 생성조차 안되며 사용되지도 않음</li>
    </ul>
  </li>
  <li>장점
    <ul>
      <li>서브 타입을 명확히 구분할 수 있음</li>
      <li>NotNull 제약조건 사용 가능</li>
    </ul>
  </li>
  <li>단점
    <ul>
      <li>여러 자식 테이블을 함께 조회할 때 <strong>UNION SQL이 발생하기에 조회 성능 DOWN</strong></li>
      <li>자식 테이블을 <strong>통합해서 Query 할 시 어려움</strong></li>
      <li>변경이라는 관점에서 안좋은 전략</li>
    </ul>
  </li>
</ul>

<h2 id="매핑-정보-상속---mapped-superclass">매핑 정보 상속 - Mapped Superclass</h2>

<h3 id="mappedsuperclass">@MappedSuperclass</h3>

<ul>
  <li>개념
    <ul>
      <li><strong>공통 매핑 정보</strong>가 필요할 때 사용 → 즉, 공통 속성이 존재할 때 이를 <strong>하나의 객체로 만들고 상속 받아 쓸</strong> 수 있게 해주는 것 [ ex) id, name ]</li>
      <li>상속관계 매핑 X</li>
      <li>Entity X, Table과 매핑되는 것도 X</li>
      <li>부모 클래스를 상속 받는 자식 클래스에 <strong>매핑 정보만 제공</strong></li>
      <li>Entity, Table이 아니므로 조회 및 검색이 불가 (<code class="language-plaintext highlighter-rouge">em.find()</code> 불가)</li>
      <li>직접 생성해서 사용할일이 없으므로 <strong>추상 클래스</strong> 권장</li>
      <li>테이블과 관계 없고, 단순히 엔티티가 <strong>공통으로 사용하는 매핑 정보를 모으는 역할</strong></li>
      <li>주로 등록일, 수정일, 등록자, 수정자 같은 전체 엔티티에서 <strong>공통으로 적용하는 정보를 모을 때 사용</strong></li>
    </ul>
  </li>
  <li>사용
    <ul>
      <li>
        <p>매핑 정보를 담은 Class (Not Entity)</p>

        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nd">@MappedSuperclass</span> <span class="c1">// Entity 로 등록 되지 않고, 이를 상속받은 Entity 들이 해당 field 를 사용할 수 있는 것!</span>
  <span class="kd">public</span> <span class="kd">abstract</span>  <span class="kd">class</span> <span class="nc">BaseEntity</span> <span class="o">{</span>
      <span class="kd">private</span> <span class="nc">String</span> <span class="n">createdBy</span><span class="o">;</span>
      <span class="kd">private</span> <span class="nc">LocalDateTime</span> <span class="n">createdDate</span><span class="o">;</span>
      <span class="kd">private</span> <span class="nc">String</span> <span class="n">lastModifiedBy</span><span class="o">;</span>
  		<span class="kd">private</span> <span class="nc">LocalDateTime</span> <span class="n">lastModifiedDate</span><span class="o">;</span>
  		<span class="o">...</span> <span class="c1">//Getter, Setter</span>
  <span class="o">}</span>
</code></pre></div>        </div>

        <ul>
          <li><code class="language-plaintext highlighter-rouge">@MappedSuperclass</code> : Entity 로 등록 되지 않고, 이를 상속받은 Entity 들이 해당 field 를 사용할 수 있는 것!</li>
        </ul>
      </li>
      <li>
        <p>공통 정보를 상속 받는 Class (Entity)</p>

        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nd">@Entity</span>
  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="kd">extends</span> <span class="nc">BaseEntity</span><span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</code></pre></div>        </div>

        <ul>
          <li><code class="language-plaintext highlighter-rouge">extends BaseEntity</code> : <code class="language-plaintext highlighter-rouge">@MappedSuperclass</code> 로 지정된 BaseEntity를 상속 받아 해당 <strong>공통 속성을 사용</strong>할 수 있게 됨!</li>
          <li>즉, 해당 Entity에 속성을 등록해 놓지 않아도 BaseEntity의 공통 속성들을 사용하고 이를 DB로 부터 저장 및 조회가 가능한 것!</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<aside>
⚠️ **[주의] @Entity 클래스의 상속**
`@Entity` Class는 다른 `@Entity`나 `@MappedSuperClass`로 지정한 Class만 상속이 가능!!

</aside>
:ET