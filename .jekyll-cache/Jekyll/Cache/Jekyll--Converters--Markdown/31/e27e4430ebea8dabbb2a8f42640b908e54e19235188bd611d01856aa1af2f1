I"p<h1 id="다양한-연관관계-매핑">다양한 연관관계 매핑</h1>

<h2 id="연관관계-매핑시-고려해야될-사항">연관관계 매핑시 고려해야될 사항</h2>

<h3 id="다중성">다중성</h3>

<ul>
  <li>다대일, 일대다, 일대일, 다대다(실무X)</li>
  <li><strong>DB 관점에서의 다중성</strong>을 고려하면 됨</li>
  <li>다중성의 관계가 헷갈릴 때는 반대편으로 생각해내면 됨 → <strong>대칭성</strong>이 있기 때문 (ex_회원과 팀의 관계가 헷갈릴 때는 팀과 회원의 관계로 생각해내면 됨)</li>
</ul>

<h3 id="방향성">방향성</h3>

<ul>
  <li>단방향, 양방향</li>
  <li><strong>테이블은 외래 키 하나로</strong> 양방향(양쪽 JOIN) 가능 → <strong>방향이라는 개념이 없음</strong></li>
  <li>하지만 객체는 <strong>Reference Field</strong>가 있는 쪽으로만 참조 가능
    <ul>
      <li>한쪽만 참조하면 <strong>단방향</strong></li>
      <li>양쪽이 서로 참조하면 <strong>양방향</strong>(← 단방향 2개)</li>
    </ul>
  </li>
</ul>

<h3 id="연관관계의-주인--mappedby">연관관계의 주인 (+ mappedBy)</h3>

<ul>
  <li>테이블은 외래 키 하나로 두테이블이 연관관계를 맺음</li>
  <li>객체의 양방향 관계는 A→B, B→A 처럼 참조가 2군데가 있음</li>
  <li>여기서 딜레마가 발생 → <strong>객체는 참조가 2군데인데 테이블의 외래키는 하나</strong> → 즉, 둘중 하나만 이 외래키를 관리해야 되는 것.</li>
  <li>그럼 누가 관리하나? → <strong>연관관계의 주인</strong></li>
  <li><strong>연관관계의 주인</strong> : <strong>외래 키를 관리하는 참조(Reference)</strong> → 보통 FK가 존재하는 Table의 Entity 로 설정 (<code class="language-plaintext highlighter-rouge">@JoinColumn</code>)</li>
  <li><strong>주인의 반대편</strong> : 외래 키에 영향을 주지 않으며 단순히 조회만 가능 (<code class="language-plaintext highlighter-rouge">mappedBy</code>)</li>
</ul>

<h2 id="연관관계-종류">연관관계 종류</h2>

<h3 id="다대일-n1-manytoone">다대일 [N:1] (@ManyToOne)</h3>

<ul>
  <li>다대일 관계
    <ul>
      <li>가장 많이 사용하는 연관관계</li>
      <li>다대일(N:1)의 반대쪽은 일대다(1:N)</li>
    </ul>
  </li>
  <li>
    <p><strong>단방향</strong> 다대일 (<code class="language-plaintext highlighter-rouge">@ManyToOne</code>)</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// Member Entity (N:1 :: N)</span>
  <span class="nd">@ManyToOne</span>
  <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"TEAM_ID"</span><span class="o">)</span>
  <span class="kd">private</span> <span class="nc">Team</span> <span class="n">team</span><span class="o">;</span>
</code></pre></div>    </div>

    <ul>
      <li>RDB 설계상 항상 다대일의 <strong>‘다’쪽에 외래키</strong> 존재</li>
      <li>그러므로 항상 <strong>Many 쪽이 연관관계의 주인</strong>이 됨</li>
      <li><code class="language-plaintext highlighter-rouge">@JoinColumn(name = "TEAM_ID")</code> 을 통해 <strong>Table의 FK와 매핑</strong></li>
      <li><strong>FK 변경 및 등록 등의 권한을 가지고 있는 연관관계의 주인</strong></li>
    </ul>
  </li>
  <li>
    <p><strong>양방향</strong> 다대일 (+ <code class="language-plaintext highlighter-rouge">@OneToMany</code>)</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// Team Entity (N:1 :: 1)</span>
  <span class="nd">@OneToMany</span><span class="o">(</span><span class="n">mappedBy</span> <span class="o">=</span> <span class="s">"team"</span><span class="o">)</span> <span class="c1">// 연관이 되어버린 놈. 주인이 아님! 당한 놈</span>
  <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">members</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
</code></pre></div>    </div>

    <ul>
      <li>단방향에서 <strong>양방향으로 전환</strong>된다 해도 <strong>테이블 변경 X</strong></li>
      <li>그저 다대일 중 <strong>‘일’에 참조가 추가</strong>되는 것</li>
      <li>이때 <code class="language-plaintext highlighter-rouge">@OneToMany</code> 를 통해 해당 Entity와의 관계가 현재 Entity의 입장에서 일대다 라는 것을 알려주고</li>
      <li><strong>연관관계의 주인이 아닌, 매핑당하고 있다</strong>는 <code class="language-plaintext highlighter-rouge">mappedBy</code> 설정</li>
      <li><strong>조회만</strong> 가능</li>
    </ul>
  </li>
</ul>

<h3 id="일대다-1n-onetomany">일대다 [1:N] (@OneToMany)</h3>

<ul>
  <li>일대다 관계
    <ul>
      <li>다대일에서 연관관계의 <strong>주인이 반대로 설정</strong>된 경우</li>
      <li>객체와 테이블의 차이 때문에 <strong>반대편 테이블의 외래 키를 관리하는 특이한 구조</strong> → 잘 사용하는 관계는 아님 → 되도록 다대일을 사용하자!</li>
      <li>원래는 일대다에서 “다”쪽에 외래키가 있지만, 다대일에서의 방식과는 다르게 “다”쪽이 아닌 <strong>“일”쪽에서 외래키를 관리</strong>하는 것 → 연관관계의 주인을 “일” 쪽으로 설정한 것</li>
      <li>즉, <strong>“일”쪽에서 값이 변할 때 “다”쪽의 외래키가 변함</strong> → 지금 변경하고 있는 Entity가 아닌 다른 Table에 UPDATE query를 날리게 되는 것 (추후 유지보수 및 최적화에 있어서 큰 단점이 될 수 있음)</li>
    </ul>
  </li>
  <li>
    <p><strong>단방향</strong> 일대다 (<code class="language-plaintext highlighter-rouge">@OneToMany</code>)</p>

    <p><img src="%E1%84%83%E1%85%A1%E1%84%8B%E1%85%A3%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%20%E1%84%86%E1%85%A2%E1%84%91%E1%85%B5%E1%86%BC%20ca18d1aaa9fa4ec2bf8cb388d975deae/Untitled.png" alt="Untitled" /></p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// Team Entity (1:N :: 1)</span>
  <span class="nd">@OneToMany</span>
  <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"TEAM_ID"</span><span class="o">)</span>
  <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">members</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
</code></pre></div>    </div>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">@OneToMany</code> : 해당 Entity와의 관계 (일대다)</li>
      <li><code class="language-plaintext highlighter-rouge">@JoinColumn(name = “TEAM_ID”)</code>
        <ul>
          <li>해당 Entity(Team)에서 <strong>외래키를 관리하겠다</strong>는 뜻</li>
          <li>고로 <strong>Member Table의 FK인 TEAM_ID 와 매핑</strong>하겠다는 것</li>
          <li><strong>연관관계의 주인</strong>을 가지게 됨</li>
        </ul>
      </li>
      <li><strong>참고</strong>
        <ul>
          <li>Team을 생성하고 Team의 members에 Member를 추가하게 되면</li>
          <li>Team Table에 INSERT query가 하나 나가고</li>
          <li><strong>Member Table에 UPDATE query가 하나 나감.</strong> (<strong>외래키(FK)를 Member가 가지</strong>고 있기 때문)</li>
          <li>즉, <strong>다대일과는 다르게 query가 하나 더 나감</strong></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>양방향</strong> 일대다 (+ <strong>@ManyToOne, @JoinColumn</strong>)</p>

    <p><img src="%E1%84%83%E1%85%A1%E1%84%8B%E1%85%A3%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%20%E1%84%86%E1%85%A2%E1%84%91%E1%85%B5%E1%86%BC%20ca18d1aaa9fa4ec2bf8cb388d975deae/Untitled%201.png" alt="Untitled" /></p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// Member Entity (1:N :: N)</span>
  <span class="nd">@ManyToOne</span>
  <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"TEAM_ID"</span><span class="o">,</span> <span class="n">insertable</span> <span class="o">=</span> <span class="kc">false</span><span class="o">,</span> <span class="n">updateable</span> <span class="o">=</span> <span class="kc">false</span><span class="o">)</span>
  <span class="kd">private</span> <span class="nc">Team</span> <span class="n">team</span><span class="o">;</span>
</code></pre></div>    </div>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">@ManyToOne</code> : 해당 Entity와의 관계를 알려주는 것</li>
      <li><code class="language-plaintext highlighter-rouge">@JoinColumn(name = "TEAM_ID", insertable = false, updateable = false)</code>
        <ul>
          <li>읽기 전용 매핑</li>
          <li><strong>FK와 매핑해준 후 강제로 읽기 전용 필드로 사용해서 양방향처럼 사용하는 방법</strong> → 설정이 없으면 해당 Entity도 연관관계에서 FK를 관리할 수 있는 권한을 얻게되어 꼬이게 됨!!</li>
        </ul>
      </li>
      <li>이런 복잡성, 강제성, 유지보수 및 최적화 문제 때문에 <strong>보통 다대일 양방향을 주로 사용</strong></li>
    </ul>
  </li>
  <li>결론 : 일대다 말고 다대일 관계를 사용하자!!</li>
</ul>

<h3 id="일대일-11-onetoone">일대일 [1:1] (@OneToOne)</h3>

<ul>
  <li>일대일 관계
    <ul>
      <li>일대일 관계의 반대 또한 일대일</li>
      <li><strong>외래 키 선택 가능</strong>! → 완전히 대칭적(1대1)이므로 <strong>어디에 두든 상관없음</strong>
        <ul>
          <li>주 테이블에 외래 키 설정 방법</li>
          <li>대상 테이블에 외래 키 설정 방법</li>
        </ul>
      </li>
      <li>외래 키에 DB UNIQUE 제약 조건 추가됨</li>
    </ul>
  </li>
  <li>
    <p><strong>단방향</strong> 일대일</p>

    <p><img src="%E1%84%83%E1%85%A1%E1%84%8B%E1%85%A3%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%20%E1%84%86%E1%85%A2%E1%84%91%E1%85%B5%E1%86%BC%20ca18d1aaa9fa4ec2bf8cb388d975deae/Untitled%202.png" alt="Untitled" /></p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// Member Entity</span>
  <span class="nd">@OneToOne</span>
  <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"LOCKER_ID"</span><span class="o">)</span>
  <span class="kd">private</span> <span class="nc">Locker</span> <span class="n">locker</span><span class="o">;</span>
</code></pre></div>    </div>

    <ul>
      <li>다대일(<code class="language-plaintext highlighter-rouge">@ManyToOne</code>) <strong>단방향 매핑과 유사</strong></li>
      <li><strong>FK 및 UNI 를 어디다 두든 상관없음!</strong>
        <ul>
          <li>Member에 LOCKER_ID로 FK및 UNI 를 넣어도 되고</li>
          <li>Locker에 MEMBER_ID로 FK및 UNI 를 넣어도 됨</li>
        </ul>
      </li>
    </ul>

    <aside>
  🚨 **단방향 일대일 연관관계 주인 역설정 (대상 테이블에 외래 키)**
  만약 단방향 일대일 관계에서 FK는 Member Table에 있는데 Locker Entity에 연관관계의 주인을 주는 경우(연관관계 주인 역설정)로 설정하고 싶다면? 
  ⇒ 불가능!! JPA에서 지원하지 않음
    
  </aside>
  </li>
  <li>
    <p><strong>양방향</strong> 일대일</p>

    <p><img src="%E1%84%83%E1%85%A1%E1%84%8B%E1%85%A3%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%20%E1%84%86%E1%85%A2%E1%84%91%E1%85%B5%E1%86%BC%20ca18d1aaa9fa4ec2bf8cb388d975deae/Untitled%203.png" alt="Untitled" /></p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// Locker Entity</span>
  <span class="nd">@OneToOne</span><span class="o">(</span><span class="n">mappedBy</span> <span class="o">=</span> <span class="s">"locker"</span><span class="o">)</span>
  <span class="kd">private</span> <span class="nc">Locker</span> <span class="n">locker</span><span class="o">;</span>
</code></pre></div>    </div>

    <ul>
      <li><strong>읽기 전용</strong>. FK를 등록하거나 수정하는 권한이 없음 (<code class="language-plaintext highlighter-rouge">mappedBy</code>)</li>
      <li>다대일(<code class="language-plaintext highlighter-rouge">@ManyToOne</code>) 양방향 매핑과 유사 (<code class="language-plaintext highlighter-rouge">mappedBy</code> 사용)</li>
    </ul>

    <aside>
  ⚠️ **양방향 일대일 연관관계 주인 역설정 (대상 테이블에 외래 키)**
    
  ![Untitled](%E1%84%83%E1%85%A1%E1%84%8B%E1%85%A3%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%20%E1%84%86%E1%85%A2%E1%84%91%E1%85%B5%E1%86%BC%20ca18d1aaa9fa4ec2bf8cb388d975deae/Untitled%204.png)
    
  만약 양방향 일대일 관계에서 FK는 Member Table에 있는데 Locker Entity에 연관관계의 주인을 주는 경우(연관관계 주인 역설정)로 설정하고 싶다면? 
  ⇒ 양방향은 가능! 두 Entity 중 FK를 가지고 있는 Entity로 연관관계 주인을 재설정하면 됨. 즉, FK가 Locker Table로 가게 되는 것 (사실 양방향 일대일 연관관계 주인 역설정이라고 할 수 없음 → 제대로된 연관관계의 주인이기 때문)
    
  </aside>
  </li>
  <li><strong>연관관계 주인 正설정 vs 易설정</strong>
    <ul>
      <li><strong>正설정 (주 테이블에 외래 키)</strong>
        <ul>
          <li>주 객체가 대상 객체의 참조를 가지는 것 처럼 <strong>주 테이블에 외래 키를 두고 대상 테이블을 찾음</strong></li>
          <li>객체지향 개발자 선호</li>
          <li>JPA 매핑 편리</li>
          <li>장점 : 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능</li>
          <li>단점 : 값이 없으면 외래 키에 <strong>null 허용</strong></li>
        </ul>
      </li>
      <li><strong>易설정 (대상 테이블에 외래 키)</strong>
        <ul>
          <li><strong>대상 테이블에 외래 키</strong>가 존재</li>
          <li>전통적인 데이터베이스 개발자 선호</li>
          <li>장점: 주 테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 때 테이블 구조 유지 가능</li>
          <li>단점
            <ul>
              <li><strong>강제적으로 양방향</strong> 일대일관계를 만들어야 함.</li>
              <li><strong>프록시 기능의 한계로 지연 로딩으로 설정해도 항상 즉시 로딩</strong>됨 → Member Entity에서 Locker Entity를 프록시로 설정하려면 Member Table의 LOCKER_ID(FK)가 null인지 아닌지 확인을 해야되는데, FK가 Locker Table에 있기 때문에 (대상 테이블에 외래키) 무조건 해당 Locker Table을 조회해봐야됨 → <strong>프록시 불가</strong></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="다대다-nm-manytomany">다대다 [N:M] (@ManyToMany)</h3>

<ul>
  <li>다대다 관계
    <ul>
      <li>RDB는 애초에 다대다(N:M) 관계를 표현할 수 없음</li>
      <li>
        <p><strong>연결 테이블을 추가해서 다대다(N:M)를 일대다(1:N), 다대일(M:1) 관계로 풀어내야 가능!</strong></p>

        <p><img src="%E1%84%83%E1%85%A1%E1%84%8B%E1%85%A3%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%20%E1%84%86%E1%85%A2%E1%84%91%E1%85%B5%E1%86%BC%20ca18d1aaa9fa4ec2bf8cb388d975deae/Untitled%205.png" alt="Untitled" /></p>
      </li>
      <li>
        <p>BUT! <strong>객체는 다대다관계가 가능!! (Collection 이용)</strong></p>

        <p><img src="%E1%84%83%E1%85%A1%E1%84%8B%E1%85%A3%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%20%E1%84%86%E1%85%A2%E1%84%91%E1%85%B5%E1%86%BC%20ca18d1aaa9fa4ec2bf8cb388d975deae/Untitled%206.png" alt="Untitled" /></p>
      </li>
      <li>그래서 <strong>다대다 관계</strong>가 가능하도록 <strong>JPA 에서 지원</strong>하는 것</li>
      <li><strong>하지만 해당 관계는 사용하면 안됨!!</strong></li>
      <li>즉, <code class="language-plaintext highlighter-rouge">@ManyToMany</code>를 사용하지 말고 <strong>연결 객체 Entity를 생성</strong>해서 <code class="language-plaintext highlighter-rouge">**@OneToMany</code> + <code class="language-plaintext highlighter-rouge">@ManyToOne</code>** 으로 풀어내야함</li>
    </ul>
  </li>
  <li>
    <p>지원되는 다대다 <strong>(실무에선 사용X)</strong></p>

    <p><img src="%E1%84%83%E1%85%A1%E1%84%8B%E1%85%A3%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%20%E1%84%86%E1%85%A2%E1%84%91%E1%85%B5%E1%86%BC%20ca18d1aaa9fa4ec2bf8cb388d975deae/Untitled%207.png" alt="Untitled" /></p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// Member Entity</span>
  <span class="nd">@ManyToMany</span>
  <span class="nd">@JoinTable</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"MEMBER_PRODUCT"</span><span class="o">,</span>
  				<span class="n">joinColumns</span> <span class="o">=</span> <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"MEMBER_ID"</span><span class="o">),</span>
  				<span class="n">inverseJoinColumns</span> <span class="o">=</span> <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"PRODUCT_ID"</span><span class="o">))</span>
  <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;</span> <span class="n">products</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
</code></pre></div>    </div>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">@ManyToMany</code> : 해당 객체와 다대다 관계라는 것을 선언</li>
      <li><code class="language-plaintext highlighter-rouge">@JoinTable(name = "MEMBER_PRODUCT")</code> : 해당 이름으로 <strong>연결 테이블 생성</strong> → <strong>서로의 PK와FK를 가지는</strong> MEMBER_PRODUCT <strong>CREATE</strong></li>
      <li>BUT 안씀!!!</li>
    </ul>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// Product Entity</span>
  <span class="nd">@ManyToMany</span><span class="o">(</span><span class="n">mappedBy</span> <span class="o">=</span> <span class="s">"products"</span><span class="o">)</span>
  <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">members</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
</code></pre></div>    </div>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">@ManyToMany(mappedBy = "products")</code> : 해당 객체와 다대다 관계라는 것은 선언하며, products에 의해 <strong>연관당하는 입장</strong>이라는 것을 선언</li>
      <li>BUT 안씀!!!</li>
    </ul>
  </li>
  <li><strong>다대다 매핑의 한계</strong>
    <ul>
      <li>편리해 보이지만 <strong>실무에서 사용X</strong></li>
      <li>중간에 매핑되고 있는 <strong>연결 테이블</strong>이 있기 때문에, 내가 생각지도 못한 query가 나갈 수 있음 → <strong>유지,보수 및 최적화 장애</strong></li>
      <li>
        <p>연결 테이블이 단순히 연결만 하고 끝나지 않음 → 주문시간, 수량과 같은 <strong>부가적인 데이터가 필요할 경우</strong>가 언젠가는 옴</p>

        <p><img src="%E1%84%83%E1%85%A1%E1%84%8B%E1%85%A3%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%20%E1%84%86%E1%85%A2%E1%84%91%E1%85%B5%E1%86%BC%20ca18d1aaa9fa4ec2bf8cb388d975deae/Untitled%208.png" alt="Untitled" /></p>
      </li>
    </ul>
  </li>
  <li><strong>다대다 매핑의 한계 극복</strong>
    <ul>
      <li><strong>“대다다”</strong>를 “<strong>일대다, 다대일”로 표현</strong>하며 <strong>중간에 엔티티를 추가!</strong></li>
      <li>즉, 연결 테이블용 엔티티 추가 → <strong>연결 테이블을 엔티티로 승격</strong></li>
      <li>추가로 PK,FK 를 혼용하지 않고 <strong>PK를 따로 줌! → 엔티티로써 사용, 유연성 증가</strong></li>
    </ul>

    <p><img src="%E1%84%83%E1%85%A1%E1%84%8B%E1%85%A3%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%20%E1%84%86%E1%85%A2%E1%84%91%E1%85%B5%E1%86%BC%20ca18d1aaa9fa4ec2bf8cb388d975deae/Untitled%209.png" alt="Untitled" /></p>

    <ul>
      <li>
        <p>MemberProduct Entity (연결 엔티티)</p>

        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nd">@Entity</span> 
  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemberProduct</span> <span class="o">{</span> 
            
        
      <span class="nd">@Id</span>
      <span class="nd">@GeneratedValue</span>
      <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>
        
      <span class="nd">@ManyToOne</span>
      <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"MEMBER_ID"</span><span class="o">)</span>
      <span class="kd">private</span> <span class="nc">Member</span> <span class="n">member</span><span class="o">;</span>
        
      <span class="nd">@ManyToOne</span>
      <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"PRODUCT_ID"</span><span class="o">)</span>
      <span class="kd">private</span> <span class="nc">Product</span> <span class="n">product</span><span class="o">;</span>
        
      <span class="kd">private</span> <span class="kt">int</span> <span class="n">count</span><span class="o">;</span>
      <span class="kd">private</span> <span class="kt">int</span> <span class="n">price</span><span class="o">;</span>
  <span class="o">}</span>
</code></pre></div>        </div>

        <ul>
          <li><code class="language-plaintext highlighter-rouge">@Entity</code>
            <ul>
              <li>다대다를 <strong>일대다+다대일 로 풀어낼 때 사용되는 객체</strong></li>
              <li><code class="language-plaintext highlighter-rouge">@ManyToMany</code> 의 연결테이블을 엔티티로 승격</li>
            </ul>
          </li>
          <li><code class="language-plaintext highlighter-rouge">@ManyToMany</code> -&gt; <code class="language-plaintext highlighter-rouge">@OneToMany</code> (Member, Product입장 → <strong>다대다를 하고자하는 Entity들</strong>), <code class="language-plaintext highlighter-rouge">@ManyToOne</code> (MemberProduct입장 → <strong>연결 Entity</strong>)
            <ul>
              <li>MemberProduct ↔ <strong>**Member : Many ↔ One ⇒ <code class="language-plaintext highlighter-rouge">@ManyToOne</code>
  MemberProduct Table의 **MEMBER_ID FK와 매핑</strong></li>
              <li>MemberProduct ↔ Product : Many ↔ One ⇒ <code class="language-plaintext highlighter-rouge">@ManyToOne</code>
  MemberProduct Table의 <strong>PRODUCT_ID FK와 매핑</strong></li>
            </ul>
          </li>
          <li>추가로 다대다를 풀어냄과 동시에 <strong>추가적인 정보</strong>를 담을 수 있음!!
  → <strong>중간 객체를 사용하는 이유</strong></li>
        </ul>
      </li>
      <li>
        <p>Member Entity (연결 엔티티와 일대다)</p>

        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nd">@OneToMany</span><span class="o">(</span><span class="n">mappedBy</span> <span class="o">=</span> <span class="s">"member"</span><span class="o">)</span>
  <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">MemberProduct</span><span class="o">&gt;</span> <span class="n">memberProducts</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
</code></pre></div>        </div>

        <ul>
          <li><code class="language-plaintext highlighter-rouge">@ManyToMany</code> -&gt; <code class="language-plaintext highlighter-rouge">@OneToMany</code> (Member, Product입장 → <strong>다대다를 하고자하는 Entity들</strong>), <code class="language-plaintext highlighter-rouge">@ManyToOne</code> (MemberProduct입장 → <strong>연결 Entity</strong>)
            <ul>
              <li>Member ↔ MemberProduct : One ↔ Many ⇒ <code class="language-plaintext highlighter-rouge">@OneToMany</code>
  MemberProduct의 member에 의해 <strong>연관당하는 입장</strong></li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        <p>Product Entity (연결 엔티티와 다대일)</p>

        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nd">@OneToMany</span><span class="o">(</span><span class="n">mappedBy</span> <span class="o">=</span> <span class="s">"product"</span><span class="o">)</span>
  <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">MemberProduct</span><span class="o">&gt;</span> <span class="n">memberProducts</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
</code></pre></div>        </div>

        <ul>
          <li><code class="language-plaintext highlighter-rouge">@ManyToMany</code> -&gt; <code class="language-plaintext highlighter-rouge">@OneToMany</code> (Member, Product입장 → <strong>다대다를 하고자하는 Entity들</strong>), <code class="language-plaintext highlighter-rouge">@ManyToOne</code> (MemberProduct입장 → <strong>연결 Entity</strong>)
            <ul>
              <li>Product ↔ MemberProduct : One ↔ Many ⇒ <code class="language-plaintext highlighter-rouge">@OneToMany</code>
  MemberProduct의 product에 의해 <strong>연관당하는 입장</strong></li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        <p>결론적으로 <code class="language-plaintext highlighter-rouge">@ManyToMany</code> 를 <code class="language-plaintext highlighter-rouge">@OneToMany</code> (Member, Product입장 → <strong>다대다를 하고자하는 Entity들</strong>) + <code class="language-plaintext highlighter-rouge">@ManyToOne</code> (MemberProduct입장 → <strong>연결 Entity</strong>) 로 풀어내 <strong>부수적인 효과(유지보수 및 최적화 여지, 필요 데이터 추가)를 얻어냄</strong></p>
      </li>
    </ul>
  </li>
</ul>
:ET