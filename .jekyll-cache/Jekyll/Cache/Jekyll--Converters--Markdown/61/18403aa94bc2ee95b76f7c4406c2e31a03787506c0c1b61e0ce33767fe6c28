I"<h2 id="api-예외-처리-소개">API 예외 처리 소개</h2>

<h3 id="api-예외-처리의-필요성">API 예외 처리의 필요성</h3>

<ul>
  <li>HTML은 간단하게 스프링 부트에서 제공하는 예외 처리를 이용하면 되었음</li>
  <li>그럼 그대로 API에서 발생한 예외도 HTML의 예외 처리 결과를 보내주면 될까? → NOPE!! <strong>API의 경우 생각할 내용이 더 많음!!</strong> (오류페이지는 단순히 오류 화면만 보여주면 끝)</li>
  <li>API는 각 <strong>오류 상황에 맞는 오류 응답 스펙을 정해서</strong> 보여줘야 됨. 또한 HTML이 아닌 <strong>JSON으로 데이터를 보내줘야됨!</strong></li>
</ul>

<h3 id="api-예외-처리---기본">API 예외 처리 - 기본</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">WebServerCustomizer</code>  를 통해 <strong>직접 ErrorPage를 등록</strong>하고 해당 path(URI)를 통해 Controller를 호출하고 <strong>JSON으로 데이터를 반환</strong>해줄 수 있도록 설정</li>
  <li>스프링 부트의 예외 페이지 처리가 아닌 <strong>서블릿의 예외 처리</strong> (직접 설정하여 진행하는) 이용!</li>
  <li><code class="language-plaintext highlighter-rouge">WebServerCustomizer</code> : Exception 파트 참고 (Exception)[링크]</li>
  <li><code class="language-plaintext highlighter-rouge">ApiExceptionController</code>
    <ul>
      <li>ErrorPage의 path(URI)에 따라 JSON 데이터를 반환할 수 있도록 설정한 Controller</li>
    </ul>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nd">@RestController</span> <span class="c1">// @ResponseBody + @Controller</span>
  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">ApiExceptionController</span> <span class="o">{</span>
    
      <span class="nd">@GetMapping</span><span class="o">(</span><span class="s">"/api/members/{id}"</span><span class="o">)</span>
      <span class="kd">public</span> <span class="nc">MemberDto</span> <span class="nf">getMember</span><span class="o">(</span><span class="nd">@PathVariable</span><span class="o">(</span><span class="s">"id"</span><span class="o">)</span> <span class="nc">String</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">if</span> <span class="o">(</span><span class="n">id</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"ex"</span><span class="o">))</span> <span class="o">{</span>
              <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"잘못된 사용자"</span><span class="o">);</span>
  				<span class="o">}</span>
    
          <span class="k">return</span> <span class="k">new</span> <span class="nf">MemberDto</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="s">"hello"</span> <span class="o">+</span> <span class="n">id</span><span class="o">);</span>
      <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div>    </div>

    <ul>
      <li>정상 호출 시 MemberDto가 Json으로 잘 반환되는 것을 확인할 수 있음</li>
      <li>예외 발생 호출 시 기존에 Error처리를 했던 Controller(<code class="language-plaintext highlighter-rouge">ErrorPageController</code>)에서 반환하는 HTML파일을 받음! → 해결 필요(웹페이지가 아니면 HTML을 직접 받아서 할 수 있는 것이 거의 없음)</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">ErrorPageController</code> 에 <strong>API 응답 추가!</strong>
    <ul>
      <li>ViewResolver를 통해 HTML을 반환했던 것에 추가로 <strong>API로도 응답할 수 있도록</strong> 설정 → <strong><code class="language-plaintext highlighter-rouge">accept=application/json</code> 에 해당하는 HandlerMethod 추가!</strong></li>
    </ul>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="s">"/error-page/500"</span><span class="o">,</span> <span class="n">produces</span> <span class="o">=</span> <span class="nc">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON_VALUE</span><span class="o">)</span>
  <span class="kd">public</span> <span class="nc">ResponseEntity</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;&gt;</span> <span class="nf">errorPage500Api</span><span class="o">(</span>
          <span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">)</span> <span class="o">{</span>
    
      <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
      <span class="nc">Exception</span> <span class="n">ex</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Exception</span><span class="o">)</span> <span class="n">request</span><span class="o">.</span><span class="na">getAttribute</span><span class="o">(</span><span class="no">ERROR_EXCEPTION</span><span class="o">);</span>
      <span class="n">result</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"status"</span><span class="o">,</span> <span class="n">request</span><span class="o">.</span><span class="na">getAttribute</span><span class="o">(</span><span class="no">ERROR_STATUS_CODE</span><span class="o">));</span>
      <span class="n">result</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"message"</span><span class="o">,</span> <span class="n">ex</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
    
      <span class="nc">Integer</span> <span class="n">statusCode</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Integer</span><span class="o">)</span> <span class="n">request</span><span class="o">.</span><span class="na">getAttribute</span><span class="o">(</span><span class="nc">RequestDispatcher</span><span class="o">.</span><span class="na">ERROR_STATUS_CODE</span><span class="o">);</span>
    
      <span class="k">return</span> <span class="k">new</span> <span class="nc">ResponseEntity</span><span class="o">&lt;&gt;(</span><span class="n">result</span><span class="o">,</span> <span class="nc">HttpStatus</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">statusCode</span><span class="o">));</span>
  <span class="o">}</span>
</code></pre></div>    </div>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">@RequestMapping(value = "/error-page/500", produces = MediaType.APPLICATION_JSON_VALUE)</code>
        <ul>
          <li><code class="language-plaintext highlighter-rouge">produces = MediaType.APPLICATION_JSON_VALUE</code> 를 통해 <strong>Accept 이 application/json 인 요청에</strong> JSON으로 데이터를 반환할 수 있는 Controller 생성</li>
          <li>“/error-page/500” 에 매핑되는 Controller도 있지만  accept = application.json 일 경우 해당 <strong>url(“/error-page/500”)의 HandlerMethod 대해 우선순위를 가짐</strong>. 즉, HTML로 반환되는 Controller가 아닌 JSON으로 반환되는 Controller로 매핑되는 것!)</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">return new ResponseEntity&lt;&gt;(result, HttpStatus.valueOf(statusCode));</code>
        <ul>
          <li>result <code class="language-plaintext highlighter-rouge">Map</code> 을 만들고 status , message 키에 오류 정보를 담은 값을 할당</li>
          <li><code class="language-plaintext highlighter-rouge">ResponseEntity</code> 를 사용해서 응답하기 때문에 <code class="language-plaintext highlighter-rouge">HttpMessageConverter</code>가 동작하면서 클라이언트에 <strong>JSON이 반환</strong>됨!</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>결론적으로 Accpet 가 application/json 이 아닌 요청에 대해선 HTML이 반환되지만, <strong>Accept가 application/json 의 요청에 대해선 JSON으로 오류 처리가 진행</strong>됨!</li>
</ul>

<h3 id="스프링-부트-기본-api-오류-처리">스프링 부트 기본 API 오류 처리</h3>

<ul>
  <li>오류 화면 처리와 마찬가지로 API 예외 처리도 <strong>스프링 부트가 제공하는 기본 오류 방식</strong> 사용 가능 → <code class="language-plaintext highlighter-rouge">BasicErrorController</code></li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">BasicErrorController</code> (<code class="language-plaintext highlighter-rouge">@RequsetMapping(”/error”)</code>)</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">produces</span> <span class="o">=</span> <span class="nc">MediaType</span><span class="o">.</span><span class="na">TEXT_HTML_VALUE</span><span class="o">)</span>
  <span class="kd">public</span> <span class="nc">ModelAndView</span> <span class="nf">errorHtml</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">)</span> <span class="o">{}</span>
    
  <span class="nd">@RequestMapping</span>
  <span class="kd">public</span> <span class="nc">ResponseEntity</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;&gt;</span> <span class="nf">error</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">)</span> <span class="o">{}</span>
</code></pre></div>    </div>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">“/error”</code> 를 처리하는 <code class="language-plaintext highlighter-rouge">errorHtml()</code>, <code class="language-plaintext highlighter-rouge">error()</code> 두 메서드 존재</li>
      <li><code class="language-plaintext highlighter-rouge">errorHtml()</code> [<strong>produces = MediaType.TEXT_HTML_VALUE</strong>] : 요청의 Accept 헤더 값이 text/html 인 경우(<strong>동일한 url에 대해 우선순위</strong>를 가짐)에는 errorHtml()을 호출하여 ModelAndView를 반환하여 view를 제공! → html화면 제공</li>
      <li><code class="language-plaintext highlighter-rouge">error()</code> : 그 외의 경우에 호출(우선순위 하위 → 상세한 설정이 없으므로). <code class="language-plaintext highlighter-rouge">ResponseEntity</code>로 JSON 데이터 반환</li>
    </ul>
  </li>
  <li>
    <p>API 오류 메시지 결과 (JSON)</p>

    <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">  </span><span class="p">{</span><span class="w">
  	 </span><span class="nl">"timestamp"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2021-04-28T00:00:00.000+00:00"</span><span class="p">,</span><span class="w">
  	 </span><span class="nl">"status"</span><span class="p">:</span><span class="w"> </span><span class="mi">500</span><span class="p">,</span><span class="w">
  	 </span><span class="nl">"error"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Internal Server Error"</span><span class="p">,</span><span class="w">
  	 </span><span class="nl">"exception"</span><span class="p">:</span><span class="w"> </span><span class="s2">"java.lang.RuntimeException"</span><span class="p">,</span><span class="w">
  	 </span><span class="nl">"trace"</span><span class="p">:</span><span class="w"> </span><span class="s2">"java.lang.RuntimeException: 잘못된 사용자</span><span class="se">\n\t</span><span class="s2">at hello.exception.web.api.ApiExceptionController.getMember(ApiExceptionController.java:19...,
  	 "</span><span class="err">message</span><span class="s2">": "</span><span class="err">잘못된</span><span class="w"> </span><span class="err">사용자</span><span class="s2">",
  	 "</span><span class="err">path</span><span class="s2">": "</span><span class="err">/api/members/ex</span><span class="s2">"
  }
</span></code></pre></div>    </div>

    <ul>
      <li>HTML에서 오류 메시지 정보를 추가적으로 확인하기 위해 했던 설정 또한 API에서도 동일하게 적용 가능 → <code class="language-plaintext highlighter-rouge">server.error.include-message=always, server.error.include-stacktrace=always, …</code></li>
    </ul>
  </li>
</ul>

<aside>
⚠️ **HTML 오류 페이지 vs API 오류 JSON**
`BasicErrorController` 를 이용하면 두 항목 모두 쉽게 오류처리가 가능! 하지만, **API는** 앞서 설명했던 것과 같이 **매 상황마다 보내줘야 하는 JSON의 스펙이 다름!** 즉, 공통적으로 처리할 수가 없다는 것. 그래서 `**BasicErrorController`를 이용한 기본 오류 처리는 HTML만** 이용함. **API는 `@ExceptionHandler`를 이용!!**

</aside>

<aside>
🚨 **즉, 이 스펙에 따라 달라져야 하는 복잡한 API는 추가적인 처리가 필요하다는 뜻!**

</aside>

<h2 id="api-예외-처리-실전">API 예외 처리 실전</h2>

<h3 id="handlerexceptionresolver">HandlerExceptionResolver</h3>

<ul>
  <li>사용 목적 : 현재 예외(<code class="language-plaintext highlighter-rouge">Exception</code>)가 발생하여 서블릿을 넘어 <strong>WAS까지 예외가 전달</strong>되면 HTTP Status는 무조건 어떤 예외든 <strong>500으로 처리</strong>가 됨. 하지만, 발생하는 예외에 따라 400,404 등 <strong>다른 상태코드도 처리</strong>하고 싶고 <strong>요구하는 스펙에 따라</strong> 메시지, 형식등을 <strong>API마다 다르게 처리</strong>하고 싶을 때 → <code class="language-plaintext highlighter-rouge">HandlerExceptionResolver</code></li>
  <li><code class="language-plaintext highlighter-rouge">HandlerExceptionResolver</code>
    <ul>
      <li><strong>Spring MVC</strong>가 제공하는 기능</li>
      <li>컨트롤러 밖으로 예외가 던져진 경우 <strong>예외를 해결하고, 동작을 새로 정의</strong>할 수 있는 방법 (기존 동작은 WAS까지 갔다가 예외처리로 넘어가는 흐름을 가진 동작. 이를 벗어나 동작을 새로 정의할 수 있다는 것)</li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">HandlerExceptionResolver</code> 적용 전</p>

        <p><img src="/images/posts/post-220624/Untitled.png" alt="Untitled" /></p>

        <ul>
          <li>컨트롤러에서 예외가 발생하고 그에 따라 예외가 WAS까지 전달되고 그 이후로는 예외처리 흐름에 따라 <code class="language-plaintext highlighter-rouge">BasicController</code>를 호출하게 됨</li>
        </ul>
      </li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">HandlerExceptionResolver</code> 적용 후</p>

        <p><img src="/images/posts/post-220624/Untitled 1.png" alt="Untitled" /></p>

        <ul>
          <li>컨트롤러에서 예외가 발생하고 해당 <strong>예외가 <code class="language-plaintext highlighter-rouge">ExceptionResolver</code>로 넘어가게 됨</strong>. 이제 여기서 WAS까지 예외가 전달되는 것이 아닌 <code class="language-plaintext highlighter-rouge">ExceptionResolver</code>가 <strong>정의한 동작을 수행</strong>(예를 들면 sendError를 동작하게 하는,,<strong>)</strong>하게 되고 <strong>그 결과가 WAS로 넘어가게 됨.</strong> 즉, <strong>WAS로는 정상 응답이 넘어</strong>가게 됨. (<strong>마치 정상적인 동작이 이루어진 것 처럼!</strong>)</li>
          <li>하지만, 컨트롤러에서 예외가 발생한 것 마찬가지 이므로 <code class="language-plaintext highlighter-rouge">postHandle()</code> 은 호출되지 않음</li>
        </ul>
      </li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">HandlerExceptionResolver</code> Interface</p>

        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">interface</span> <span class="nc">HandlerExceptionResolver</span> <span class="o">{</span>
  	 <span class="nc">ModelAndView</span> <span class="nf">resolveException</span><span class="o">(</span>
  				<span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span>
  				<span class="nc">Object</span> <span class="n">handler</span><span class="o">,</span> <span class="nc">Exception</span> <span class="n">ex</span><span class="o">);</span>
  <span class="o">}</span>
</code></pre></div>        </div>

        <ul>
          <li><code class="language-plaintext highlighter-rouge">Object handler</code> : 컨트롤러 정보</li>
          <li><code class="language-plaintext highlighter-rouge">Exception ex</code> : 컨트롤러에서 발생한 예외</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>예외에 따른 상태코드 변환</strong>
    <ul>
      <li>ExceptionResolver를 사용하지 않으면 <strong>서버에서 발생한 Exception은 무조건 500</strong>으로 나감</li>
      <li>이 Exception을 경우에 따라 API 스펙 변환보다는 우선적으로 <strong>상태코드를 400,404 로 변환</strong>하고 싶은 상황</li>
      <li>해당 상황에 맞게 <code class="language-plaintext highlighter-rouge">HandlerExceptionResolver</code> 를 구현한 ExceptionResolver를 만들고 WebConfig에 등록!</li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">MyHandlerExceptionResolver</code></p>

        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nd">@Slf4j</span>
  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyHandlerExceptionResolver</span> <span class="kd">implements</span> <span class="nc">HandlerExceptionResolver</span> <span class="o">{</span>
      <span class="nd">@Override</span>
      <span class="kd">public</span> <span class="nc">ModelAndView</span> <span class="nf">resolveException</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">handler</span><span class="o">,</span> <span class="nc">Exception</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">try</span> <span class="o">{</span>
              <span class="k">if</span> <span class="o">(</span><span class="n">ex</span> <span class="k">instanceof</span> <span class="nc">IllegalArgumentException</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// Illegal.. 이 발생하면 직접 컨트롤 하겠다는 것</span>
                  <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"IllegalArgumentException resovler to 400"</span><span class="o">);</span>
                  <span class="n">response</span><span class="o">.</span><span class="na">sendError</span><span class="o">(</span><span class="nc">HttpServletResponse</span><span class="o">.</span><span class="na">SC_BAD_REQUEST</span><span class="o">,</span> <span class="n">ex</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span> <span class="c1">// 기존에 제공하는 500이 아닌, 400으로 변환해서 response에 error를 보내주는 것</span>
                  <span class="k">return</span> <span class="k">new</span> <span class="nf">ModelAndView</span><span class="o">();</span> <span class="c1">// 빈 모델,View를 보내주면 알아서 그냥 return 되어 직접 설정한 Error만을 response하게 됨</span>
              <span class="o">}</span> <span class="c1">// 즉, 실제 발생한 예외를 먹어버리고 내가 만든 예외를 발동시키는 것</span>
          <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
              <span class="n">log</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"resolver ex"</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
          <span class="o">}</span>
          <span class="k">return</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// 위의 로직이 처리되지 않으면 Exception이 그대로 WAS까지 날라감 (기존에 발생한 예외를 서블릿 밖으로 던진다!)</span>
      <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div>        </div>

        <ul>
          <li>앞서 봤던 흐름과 같이, 컨트롤러에서 Exception이 발생하면 <strong>그 Exception을 해당 <code class="language-plaintext highlighter-rouge">ExceptionResovler</code>가 받게 됨</strong></li>
          <li>
            <p><code class="language-plaintext highlighter-rouge">response.sendError()</code> 를 통해서 예외(Exception)처리 흐름을 <strong>정상흐름으로 변경</strong> (Exception을 잡아서 <strong>내가 원하는 동작으로 처리</strong>해주는 역할) → <code class="language-plaintext highlighter-rouge">IllegalArgumentException</code> 이 발생하면 <code class="language-plaintext highlighter-rouge">response.sendError(400)</code> 를 호출해서 HTTP 상태 코드를 400으로 지정하고, 빈 ModelAndView 를 반환</p>

            <aside>
  ⚠️ <strong>Exception 발생 vs response.sendError() 추가</strong>
  <ul>
  <li>결론적인 오류에 대한 처리이기에 Exception 과 response.sendError는 똑같다고 생각할 수 있지만, <b>엄연히 다른 것!</b></li>
  <li><code>Exception</code>이 발생하면 정상흐름으로 가지 않고 <b>예외가 발생했다는 흐름으로 WAS가 받게</b> 됨</li>
  <li><code>response.sendError()</code> 는 response에다가 Error를 추가하는 것이므로 <b>WAS까지는 정상흐름으로 가게 되는 것!</b></li>
  <li>즉, 각각에 <b>흐름 자체가 달라짐!</b> (Exception은 ExceptionResolver가 발동, postHandler는 동작하지 않음. <code>response.sendError()</code>는 ExceptionResolver가 발동되지 않고 정상흐름이기에 postHandler 동작) </li>
  <li>결정적으로 <b><code>response.sendError()</code> 는 내가 원하는 Error로 custom이 가능!</b> (status 설정 등)</li>
  </ul>
  </aside>
          </li>
          <li>빈 모델,View를 보내주면 알아서 그냥 return 되어 직접 설정한 Error만을 response하게 됨. (ModelAndView 값이 없기에 렌더링 되지 않고 <strong>해당 response가 WAS까지 전달</strong>됨)</li>
          <li>
            <p>만약 다른 Exception이 터지면 null을 반환함으로써 <strong>기존 예외처리 흐름</strong>을 가지게 함 (기존에 발생한 예외를 <strong>서블릿 밖으로 던진다!</strong> → ExceptionHandler 적용 전 예외처리 흐름)</p>

            <aside>
  💡 <strong>ExceptionResolver의 반환 값에 따른 DispatcherServlet 동작 방식</strong>
  <ul>
  <li><strong>빈 ModelAndView</strong>: <code>new ModelAndView()</code> 처럼 빈 ModelAndView 를 반환하면 뷰를 렌더링 하지 않고, <b>정상 흐름</b>으로 서블릿이 리턴됨 </li>
  <li><strong>ModelAndView 지정</strong>: ModelAndView 에 View , Model 등의 정보를 지정해서 반환하면 <b>뷰를 렌더링</b>함 </li>
  <li><strong>null</strong>: null 을 반환하면, <b>다음 ExceptionResolver 를 찾아서 실행</b>. 만약 처리할 수 있는 ExceptionResolver 가 없으면 예외 처리가 안되고, 기존에 발생한 <b>예외를 서블릿 밖으로 던짐</b> </li>
  </ul>
  </aside>
          </li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">WebConfig</code>
        <ul>
          <li>구현된 HandlerException을 등록</li>
        </ul>

        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">extendHandlerExceptionResolvers</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">HandlerExceptionResolver</span><span class="o">&gt;</span> <span class="n">resolvers</span><span class="o">)</span> <span class="o">{</span>
  		<span class="n">resolvers</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">MyHandlerExceptionResolver</span><span class="o">());</span>
  <span class="o">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>ExceptionResolver 활용
    <ul>
      <li><strong>예외 상태 코드 변환</strong>
        <ul>
          <li>발생된 예외를 잡아서 response.sendError() 호출로 <strong>자신이 원하는 상태코드로 변경</strong>하여 처리 (빈 ModelAndView(<code class="language-plaintext highlighter-rouge">return new ModelAndView()</code>)를 반환하는 상황)</li>
          <li>WAS는 <code class="language-plaintext highlighter-rouge">response.sendError()</code> 를 받아서 해당 상태코드에 맞는 오류 처리 진행 → <code class="language-plaintext highlighter-rouge">BasicErrorController</code>호출 <em>**</em>(html 렌더링, API JSON 제공)</li>
        </ul>
      </li>
      <li><strong>뷰 템플릿 처리</strong>
        <ul>
          <li>ModelAndView에 값을 넣어 <strong>새로운 오류 화면 뷰 렌더링</strong></li>
        </ul>
      </li>
      <li><strong>API 응답 처리</strong>
        <ul>
          <li>요구되는 스펙에 맞게 객체를 생성하고 객체를 JSON으로 변경한 후</li>
          <li><code class="language-plaintext highlighter-rouge">response.sendError()</code> 가 아닌 <code class="language-plaintext highlighter-rouge">response.getWriter().println(JSON)</code>처럼 <strong>응답 바디에 직접 데이터를 넣어주는 것</strong></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="handlerexceptionresolver-활용">HandlerExceptionResolver 활용</h3>

<ul>
  <li>예외를 ExceptionResolver에서 끝내기!
    <ul>
      <li>지금까지 살펴본 것(Exception 발생 or ExceptionResolver에서 response.sendError() 추가)의 예외 발생 흐름을 보면 예외 발생 시 WAS까지 예외가 전달되고, <strong>WAS에서 다시 그 예외에 대한 정보를 통해 “/error”를 호출하는 과정</strong>은 생각해보면 너무 복잡함!</li>
      <li>ExceptionResolver를 활용해서 직접 상태코드를 변경하고 뷰 템플릿을 처리하거나 API 응답에 대해 JSON으로 데이터를 보낼 수 있었음 즉, <strong>ExceptionResolver를 활용하면 ExceptionResolver 그 자체에서 예외에 대한 처리를 끝낼 수 있음!</strong></li>
    </ul>
  </li>
  <li>ExceptionResolver에서 끝내기
    <ul>
      <li>custom Exception UserException 추가 → <code class="language-plaintext highlighter-rouge">public class UserException extends RuntimeException</code></li>
      <li>UserException 을 처리하는 <code class="language-plaintext highlighter-rouge">UserHandlerExceptionResolver</code> 생성 및 추가하여 ExceptionResolver 안에서 <strong>해당 예외에 대한 처리를 끝내버리기</strong> (즉, 예외에 대한 처리가 WAS까지 가지 않는 것 → <strong>뷰 렌더링 해버리거나 JSON 데이터를 response에 담는 것</strong>)</li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">UserHandlerExceptionResolver</code></p>

        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nd">@Slf4j</span>
  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserHanlderExceptionResolver</span> <span class="kd">implements</span> <span class="nc">HandlerExceptionResolver</span> <span class="o">{</span>
        
      <span class="kd">private</span> <span class="nc">ObjectMapper</span> <span class="n">objectMapper</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectMapper</span><span class="o">();</span>
        
      <span class="nd">@Override</span>
      <span class="kd">public</span> <span class="nc">ModelAndView</span> <span class="nf">resolveException</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">handler</span><span class="o">,</span> <span class="nc">Exception</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
        
          <span class="k">try</span> <span class="o">{</span>
              <span class="k">if</span> <span class="o">(</span><span class="n">ex</span> <span class="k">instanceof</span> <span class="nc">UserException</span><span class="o">)</span> <span class="o">{</span>
                  <span class="o">...</span>
                  <span class="c1">// json 용 에러 반환</span>
                  <span class="k">if</span> <span class="o">(</span><span class="s">"application/json"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">acceptHeader</span><span class="o">))</span> <span class="o">{</span>
                      <span class="o">...</span> <span class="c1">// Map 생성</span>
                      <span class="n">response</span><span class="o">.</span><span class="na">setContentType</span><span class="o">(</span><span class="s">"application/json"</span><span class="o">);</span>
                      <span class="n">response</span><span class="o">.</span><span class="na">setCharacterEncoding</span><span class="o">(</span><span class="s">"utf-8"</span><span class="o">);</span>
                      <span class="n">response</span><span class="o">.</span><span class="na">getWriter</span><span class="o">().</span><span class="na">write</span><span class="o">(</span><span class="n">result</span><span class="o">);</span> <span class="c1">// Error가 발생했을 때, Was로 갔다가 다시 error에 대한 Controller 호출하는 것이 아니라.</span>
                      <span class="c1">// 이 자체에서 write을 통해 끝내버리는 것! (효율적)</span>
                      <span class="k">return</span> <span class="k">new</span> <span class="nf">ModelAndView</span><span class="o">();</span> <span class="c1">// 아무것도 반환하지 않게 하여 그냥 response로 동작하게 설정</span>
                  <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                      <span class="c1">// TEXT/HTML</span>
                      <span class="k">return</span> <span class="k">new</span> <span class="nf">ModelAndView</span><span class="o">(</span><span class="s">"error/500"</span><span class="o">);</span> <span class="c1">// accept가 html일 때의 경우 그냥 View Rendering</span>
                      <span class="c1">// 이 자체에서 ModelAndView에 view를 넣어주면서 끝내버리는 것! (효율적)</span>
  								<span class="o">...</span>
          <span class="o">}</span>
          <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
      <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div>        </div>

        <ul>
          <li><strong>요청 헤더의 Aceept에 따라</strong> 반환되는 결과물을 <strong>지정</strong>해 줘야됨
            <ol>
              <li>요청 헤더의 <strong>Accept이 application/json</strong> 인 경우</li>
            </ol>
            <ul>
              <li><strong>JSON으로 보내줄 데이터</strong>를 Map(<code class="language-plaintext highlighter-rouge">errorResult</code>)으로 만들어서 오류 정보를 생성 → <code class="language-plaintext highlighter-rouge">String result = objectMapper.writeValueAsString(errorResult);</code></li>
              <li>해당 데이터에 대한 설정 후 <strong>response에 결과물을 작성</strong>해줌 → <code class="language-plaintext highlighter-rouge">response.getWriter().write(result);</code> , <code class="language-plaintext highlighter-rouge">return new ModelAndView();</code> ⇒ <strong>이 자체에서 write을 통해 끝내버리는 것!</strong>
      2. 요청 헤더의 <strong>Accept이 text/html</strong> 인 경우</li>
              <li><code class="language-plaintext highlighter-rouge">return new ModelAndView("error/500");</code> → accept가 html일 때의 경우 그냥 View Rendering하여 ModelAndView가 동작하여 끝내버림</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">WebConfig</code> 를 통해 <code class="language-plaintext highlighter-rouge">ExceptionResolver</code> 등록</p>

        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">extendHandlerExceptionResolvers</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">HandlerExceptionResolver</span><span class="o">&gt;</span> <span class="n">resolvers</span><span class="o">)</span> <span class="o">{</span>
  	 <span class="n">resolvers</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">MyHandlerExceptionResolver</span><span class="o">());</span>
  	 <span class="n">resolvers</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">UserHandlerExceptionResolver</span><span class="o">());</span>
  <span class="o">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong>결론</strong>
    <ul>
      <li>ExceptionResolver 를 사용하면 컨트롤러에서 예외가 발생해도 ExceptionResolver 에서 예외를 처리.  따라서 예외가 발생해도 서블릿 컨테이너까지 예외가 전달되지 않고, 스프링 MVC에서 예외 처리가 끝남</li>
      <li>즉, 예외가 WAS 까지 갔다가 다시 WAS가 그에 따른 오류처리 과정이 다시 진행되는 비효율적인 흐름을 방지하는 것! → 효율적</li>
      <li>결론적으로 WAS입장에서는 정상처리로 진행된 것.</li>
      <li>이렇게 Exception을 ExceptionResolver에서 모두 처리할 수 있다는 것이 핵심</li>
      <li>근데 이렇게 매번 모든 Exception에 대해 ExceptionResolver를 정의하고 해당 처리에 대한 구현을 진행하기에는 코드가 너무 복잡함! (객체를 Json으로 바꾸고… 하는 과정들)</li>
      <li>스프링은 이런 과정을 자동으로 처리하게끔 기능을 지원함! ⇒ <code class="language-plaintext highlighter-rouge">@ExceptionHandler</code> (<strong>ExceptionHandlerExceptionResolver</strong>)</li>
    </ul>
  </li>
</ul>

<h2 id="스프링이-제공하는-exceptionresolver">스프링이 제공하는 ExceptionResolver</h2>

<ul>
  <li>스프링 부트가 <strong>기본으로 제공하는 ExceptionResolver (우선순위 순으로)</strong>
    <ol>
      <li><strong>ExceptionHandlerExceptionResolver</strong> : <code class="language-plaintext highlighter-rouge">**@ExceptionHandler**</code> 을 처리. API 예외 처리는 대부분 해당 어노테이션으로 해결 가능!</li>
      <li>ResponseStatusExceptionResolver : <strong>HTTP 상태 코드 지정</strong> 가능</li>
      <li>DefaultHandlerExceptionResolver : <strong>스프링 내부 기본 예외</strong>를 처리</li>
    </ol>
  </li>
</ul>

<h3 id="responsestatusexceptionresolver"><strong>ResponseStatusExceptionResolver</strong></h3>

<ul>
  <li>예외에 따라서 <strong>HTTP 상태 코드를 지정</strong>해주는 역할</li>
  <li><code class="language-plaintext highlighter-rouge">@ResponseStatus</code> 가 달려있는 custom Exception, <code class="language-plaintext highlighter-rouge">ResponseStatusException</code> 을 통한 기본 Exception, 의 두가지 경우 처리</li>
  <li><code class="language-plaintext highlighter-rouge">@ResponseStatus</code>
    <ul>
      <li>HTTP 상태 코드를 변경 (500 → ? )</li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">BadRequestException</code> 이라는 custom Exception 에 <code class="language-plaintext highlighter-rouge">@ResponseStatus</code> 를 통해 원하는 상태 코드로 변경</p>

        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nd">@ResponseStatus</span><span class="o">(</span><span class="n">code</span> <span class="o">=</span> <span class="nc">HttpStatus</span><span class="o">.</span><span class="na">BAD_REQUEST</span><span class="o">,</span> <span class="n">reason</span> <span class="o">=</span> <span class="s">"잘못된 요청 오류"</span><span class="o">)</span>
  		<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BadRequestException</span> <span class="kd">extends</span> <span class="nc">RuntimeException</span> <span class="o">{</span>
  <span class="o">}</span>
</code></pre></div>        </div>

        <ul>
          <li>500 status 를 400 status로 변경</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">BadRequestException</code> 가 Controller 에서 발생하여 ExceptionResolver 까지 넘어가게 되면 ExceptinoResolver 중 <code class="language-plaintext highlighter-rouge">ResponseStatusExceptionResolver</code> 가 <strong>해당 예외의 애노테이션을 확인</strong>해서 <strong>오류 상태코드를 400 으로 변경하고 메시지도 담음</strong></li>
      <li>해당 <code class="language-plaintext highlighter-rouge">ExceptionResolver</code>는 사실 <code class="language-plaintext highlighter-rouge">**response.sendError(statusCode, resolvedReason)</code>를 통해 상태코드를 변경하는 것**을 확인할 수 있음</li>
      <li>즉, <code class="language-plaintext highlighter-rouge">sendError(400)</code> 를 호출했기 때문에 WAS에서 다시 오류 페이지 ” /error “ 를 내부에서 요청하는 것!!</li>
      <li>추가로 reason 에 message source를 이용하여 메시지를 전달할 수도 있음 → <code class="language-plaintext highlighter-rouge">reason = "error.bad"</code> (messages.properties 의 error.bad 메시지 값을 가져옴)</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">ResponseStatusException</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">@ResponseStatus</code> 는 <strong>개발자가 직접 변경할 수 없는 예외에는 적용할 수 없음</strong>. (애노테이션을 직접 다는 것이기에 Custom Exception, 변경 가능한 Exception 만 적용 가능). 또한 <strong>동적으로 변경하는 것도 어려움</strong></li>
      <li>이럴 때는 <code class="language-plaintext highlighter-rouge">ResponseStatusException</code> 을 사용</li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">ApiExceptionController</code></p>

        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nd">@GetMapping</span><span class="o">(</span><span class="s">"/api/response-status-ex2"</span><span class="o">)</span>
  <span class="kd">public</span> <span class="nc">String</span> <span class="nf">responseStatusEx2</span><span class="o">()</span> <span class="o">{</span>
   <span class="k">throw</span> <span class="k">new</span> <span class="nf">ResponseStatusException</span><span class="o">(</span>
  			<span class="nc">HttpStatus</span><span class="o">.</span><span class="na">NOT_FOUND</span><span class="o">,</span> <span class="s">"error.bad"</span><span class="o">,</span> 
  			<span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">()</span> <span class="o">);</span>
  <span class="o">}</span>
</code></pre></div>        </div>

        <ul>
          <li><code class="language-plaintext highlighter-rouge">IllegalArgumentException</code> 에 대해 404로 상태코드를 변경하고 원하는 메시지도 넣어줌</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="defaulthandlerexceptionresolver"><strong>DefaultHandlerExceptionResolver</strong></h3>

<ul>
  <li>스프링 내부에서 발생하는, 스프링 예외를 해결</li>
  <li>대표적인 것이 바로 <code class="language-plaintext highlighter-rouge">TypeMismatchException</code>
    <ul>
      <li>파라미터 바인딩 시점에 타입이 맞지 않으면 발생</li>
      <li>ExceptionResolver 없이 예외가 처리될 경우 <strong>서블릿 컨테이너까지 오류가 올라</strong>가고, <strong>결과적으로 500 오류가 발생</strong></li>
      <li>하지만 <code class="language-plaintext highlighter-rouge">TypeMismatchException</code> 는 서버 오류라기 보다는 클라이언트가 요청 정보를 잘못 호출해서 발생하는 문제. <strong>즉, 400으로 상태코드가 나가는게 옳음!</strong></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">DefaultHandlerExceptionResolver</code> 는 이것을 500 오류가 아니라 <strong>HTTP 상태 코드 400 오류로 변경</strong></li>
  <li>해당 오류뿐만 아니라 굉장히 <strong>다양한 Exceptioin들에 대해서 스프링이 해당 Exception에 맞는 상태코드로 변경해서 나갈 수 있도록 자동으로 설정</strong>해 둠. (<code class="language-plaintext highlighter-rouge">response.sendError()</code> 를 통해 → WAS에서 다시 오류 페이지 ”/error“ 를 내부 요청하는 것)</li>
</ul>

<aside>
💡 **지금까지의 ExceptionResolver**

1. ResponseStatusExceptionResolver : HTTP 응답 코드 변경 가능 (Custom Exception → `@ResponseStatus`, 기존 Exception → `ResponseStatusException`)
2. DefaultHandlerExceptionResolver : 스프링 내부 예외 처리 (기본적으로 발생할 수 있는 Exception들에 대해 자동으로 응답 코드를 변경해서 보내줌)
3.  HandlerExceptionResolver를 직접 구현하여 사용 → 실용적으로 사용하기에는 복잡! (API 오류 응답의 경우 response 에 직접 데이터를 넣어야 함) → 스프링이 제공하는 **ExceptionHandlerExceptionResolver**를 통해 간편하게 처리 가능!  ⇒ `@ExceptionHandler` (**ExceptionHandlerExceptionResolver**)
</aside>

<h3 id="exceptionhandler-exceptionhandlerexceptionresolver">@ExceptionHandler (<strong>ExceptionHandlerExceptionResolver</strong>)</h3>

<ul>
  <li><strong>ExceptionHandlerExceptionResolver</strong>를 사용하지 않을 때
    <ul>
      <li><strong>API 오류 처리를 위해 스프링이 제공하는 ExceptinoResolver</strong></li>
      <li>API 오류는 해당 상황에 따른 <strong>스펙에 맞게 오류 처리 데이터</strong>를 보내줘야함.</li>
      <li>이를 하기 위해선 우린 HandlerExceptionResolver를 <strong>직접 구현해 봤지만</strong>, 직접 JSON 데이터를 생성하고 response에 담아주는 등, <strong>과정이 복잡하고 효율적이지 않았음</strong>.</li>
      <li>추가로 HandlerExceptionResolver는 <strong>필수적으로 ModelAndView를 반환</strong>해야 했음. → API에는 필요 없는 것</li>
      <li>또한, 같은 Exception이라도 각각의 <strong>상황에 따라 반환되어야 하는 스펙이 다름!</strong> → 구현이 더욱 더 복잡해짐</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">**@ExceptionHandler**</code>
    <ul>
      <li>스프링은 <strong>API 예외 처리 문제를 해결</strong>하기 위해 <code class="language-plaintext highlighter-rouge">@ExceptionHandler</code> 라는 애노테이션을 사용하는 매우 편리한 예외 처리 기능을 제공. 이게 바로 <strong>ExceptionHandlerExceptionResolver</strong></li>
      <li>ExceptionResolver 중에서 <strong>우선순위가 가장 높은</strong> Resolver!</li>
      <li>실무에서 API 예외 처리는 <strong>대부분 이 기능을 사용</strong>함</li>
      <li><strong>각각의 컨트롤러 만의 예외처리가 가능</strong>하기 때문에 API 오류처리에 효율적임!</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">@ExceptionHandler</code> 사용
    <ul>
      <li>
        <p>응답 객체 (ErorrResult)</p>

        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nd">@Data</span>
  <span class="nd">@AllArgsConstructor</span>
  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">ErrorResult</span> <span class="o">{</span>
  	 <span class="kd">private</span> <span class="nc">String</span> <span class="n">code</span><span class="o">;</span>
  	 <span class="kd">private</span> <span class="nc">String</span> <span class="n">message</span><span class="o">;</span>
  <span class="o">}</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">@ExceptionHandler</code> (Controller 안에)</p>
        <ul>
          <li>해당 컨트롤러에서 <strong>예외가 발생하면 얘가 잡아서 이 로직을 수행</strong>함.</li>
          <li>즉, 이 어노테이션 하나로 custom ExceptionHandler를 설정하는 것</li>
          <li>해당 예외가 발생하면 <strong>먼저 ExceptionHandler에게 해당 예외를 처리하라고 요청</strong></li>
          <li>그럼 ExceptionHandler에게 <strong>우선순위의 Handler들을 통해 예외 처리</strong>를 시도</li>
          <li>여기서 <code class="language-plaintext highlighter-rouge">@ExceptionHandler</code>가 <strong>우선순위</strong>에 있기 때문에 얘가 수행 되는 것 (해당 Controller에 있다면)</li>
          <li>근데 여기서 Handle을 해줬기 때문에 <strong>정상흐름으로 인식</strong> → 즉, <strong>따로 설정하지 않으면 status가 200이 반환</strong>됨 ⇒ <strong>상태코드 변경 필요</strong>!</li>
          <li><strong>다른 컨트롤러 Method와 똑같이 동작</strong>함. 즉, 컨트롤러가 하는 <strong>역할과 파라미터, 어노테이션, 반환 값 사용 가능</strong>!</li>
          <li>참고로 Controller 처럼 작동하기 때문에 String을 반환할 경우 ViewResolver가 동작하여 HTML로도 응답할 수 있음 (But 잘 사용 안함) → <strong><code class="language-plaintext highlighter-rouge">@ExceptionHandler</code> 는 보통 API 오류 처리용</strong></li>
          <li>
            <ul>
              <li>
                <p><code class="language-plaintext highlighter-rouge">@ResponseSatus()</code></p>

                <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@ResponseStatus</span><span class="o">(</span><span class="nc">HttpStatus</span><span class="o">.</span><span class="na">BAD_REQUEST</span><span class="o">)</span>
<span class="nd">@ExceptionHandler</span><span class="o">(</span><span class="nc">IllegalArgumentException</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="nc">ErrorResult</span> <span class="nf">illegalExHandle</span><span class="o">(</span><span class="nc">IllegalArgumentException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
	 <span class="n">log</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"[exceptionHandle] ex"</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
	 <span class="k">return</span> <span class="k">new</span> <span class="nf">ErrorResult</span><span class="o">(</span><span class="s">"BAD"</span><span class="o">,</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div>                </div>

                <ul>
                  <li><code class="language-plaintext highlighter-rouge">@ResponseSatus</code> 를 통해 <strong>상태코드 변경</strong> (200 → 오류코드) → (<code class="language-plaintext highlighter-rouge">@ResponseSatus</code>는 원래 Controller에 붙일 수 있는 놈)</li>
                  <li>해당 <code class="language-plaintext highlighter-rouge">IllegalArgumentException</code> 포함 하위 Exception에 대해선 이 ExceptionHandler가 동작</li>
                  <li>컨트롤러와 같이 동작하기 때문에 <strong>ResponseBody가 적용 되어 MessageConverter가 동작!</strong> → JSON으로 데이터가 반환됨</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            <ul>
              <li>
                <p><code class="language-plaintext highlighter-rouge">ResponseEntity&lt;&gt;</code></p>

                <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@ExceptionHandler</span> <span class="c1">// 생략하면 자동으로 인자에 있는 Exception 할당</span>
<span class="kd">public</span> <span class="nc">ResponseEntity</span><span class="o">&lt;</span><span class="nc">ErrorResult</span><span class="o">&gt;</span> <span class="nf">userExHandler</span><span class="o">(</span><span class="nc">UserException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">log</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"[exceptionHandler] ex"</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
    <span class="nc">ErrorResult</span> <span class="n">errorResult</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ErrorResult</span><span class="o">(</span><span class="s">"USER-EX"</span><span class="o">,</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nc">ResponseEntity</span><span class="o">&lt;&gt;(</span><span class="n">errorResult</span><span class="o">,</span> <span class="nc">HttpStatus</span><span class="o">.</span><span class="na">BAD_REQUEST</span><span class="o">);</span>
<span class="o">}</span> <span class="c1">// @ExceptionHandler 기존 Controller와 같이 정상 흐름으로 작동하기에</span>
 <span class="c1">// 기존 Controller와 같이 사용할 수 있음 -&gt; ResponseEntity를 이용하여 status 설정정</span>
</code></pre></div>                </div>

                <ul>
                  <li><code class="language-plaintext highlighter-rouge">ResponseEntity&lt;&gt;</code> 를 통해 <strong>JSON을 반환하며 상태코드를 변경</strong> (200 → 오류코드)</li>
                  <li>해당 <code class="language-plaintext highlighter-rouge">UserException</code>  포함 하위 Exception에 대해선 이 ExceptionHandler가 동작</li>
                  <li>Method의 파라미터가 <code class="language-plaintext highlighter-rouge">@ExceptionHandler</code>가 다루는 Exception과 동일하다면 생략 가능</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            <p>다양한 예외 공통 처리</p>

            <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nd">@ExceptionHandler</span><span class="o">({</span><span class="nc">AException</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="nc">BException</span><span class="o">.</span><span class="na">class</span><span class="o">})</span>
  <span class="kd">public</span> <span class="nc">String</span> <span class="nf">ex</span><span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
  	 <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"exception e"</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
  <span class="o">}</span>
</code></pre></div>            </div>

            <ul>
              <li>두가지 예외에 대해서도 같이 처리 가능</li>
              <li>두 예외의 부모로 인자를 받으면 됨</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<aside>
💡  **Exception 발생 시 `@ExceptionHandler` 실행 흐름**

- 컨트롤러를 호출한 결과 Exception이 컨트롤러 밖으로 던져짐
- 예외가 발생했으로 ExceptionResolver가 작동. ExceptionResolver 중 가장 **우선순위가 높은 ExceptionHandlerExceptionResolver 가 실행**됨
- ExceptionHandlerExceptionResolver 는 해당 컨트롤러에 **해당 Exception을 처리할 수 있는 `@ExceptionHandler` 가 있는 지 확인**
- 해당 `@ExceptionHandler` 의 Method 실행. `@RestController` 의 영향을 받아 `@ResponseBody` 가 적용(혹은 `ResponseEntity` 적용) → HttpMessageConverter 적용 → JSON으로 반환
- `@ResponseStatus(HttpStatus.BAD_REQUEST)` 를 지정(혹은 ResponseEntity의 상태코드를 지정)했으므로 HTTP 상태 코드 400으로 응답
</aside>

<h3 id="exceptionhandler-with-controlleradvice">@ExceptionHandler with @ControllerAdvice</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">@ExceptionHandler</code> 를 사용해서 예외를 깔끔하게 처리할 수 있게 되었지만, <strong>정상 코드와 예외 처리 코드가 하나의 컨트롤러에 섞여 있음!</strong></li>
  <li><code class="language-plaintext highlighter-rouge">@ControllerAdvice</code>(, <code class="language-plaintext highlighter-rouge">@RestControllerAdvice</code>)를 사용하면 둘을 분리하여 좀 더 깔끔한 코드를 작성할 수 있음</li>
  <li><code class="language-plaintext highlighter-rouge">@ControllerAdvice</code>
    <ul>
      <li>ExceptinonHanlder를 <strong>기본 Controller와 분리해서 사용할 수 있는 Advice</strong></li>
      <li>대상으로 지정한 여러 컨트롤러에 <code class="language-plaintext highlighter-rouge">@ExceptionHandler</code> , <code class="language-plaintext highlighter-rouge">@InitBinder</code> 기능을 부여해주는 역할</li>
      <li>여러 다양한 Controller에서 발생하는 Exception을 공통적으로(글로벌) 처리 가능 (대상을 지정하지 않으면)</li>
    </ul>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ExControllerAdvice</code> ← <code class="language-plaintext highlighter-rouge">@RestControllerAdvice</code></p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nd">@RestControllerAdvice</span> <span class="c1">// @ControllerAdvice + @ResponseBody</span>
  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">ExControllerAdvice</span> <span class="o">{</span>
    
      <span class="nd">@ResponseStatus</span><span class="o">(</span><span class="nc">HttpStatus</span><span class="o">.</span><span class="na">BAD_REQUEST</span><span class="o">)</span> <span class="c1">// 아래 코드는 정상 흐름으로 인식하므로, 직접 status 정의</span>
      <span class="nd">@ExceptionHandler</span><span class="o">(</span><span class="nc">IllegalArgumentException</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="c1">// 해당 Exception에 대해서 처리하겠다는 뜻</span>
      <span class="kd">public</span> <span class="nc">ErrorResult</span> <span class="nf">illegalExHandler</span><span class="o">(</span><span class="nc">IllegalArgumentException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">log</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"[exceptionHandler] ex"</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
          <span class="k">return</span> <span class="k">new</span> <span class="nf">ErrorResult</span><span class="o">(</span><span class="s">"BAD"</span><span class="o">,</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
      <span class="o">}</span>
  		<span class="o">...</span>
  <span class="o">}</span>
</code></pre></div>    </div>

    <ul>
      <li>이런 식으로 Controller를 생성하듯이 ControllerAdvice를 생성하면 됨!</li>
      <li>해당 ControllerAdvice에 <strong>원하는 ExceptionHandler를 지정</strong>해주면 됨</li>
      <li>만약 ControllerAdvice에 <strong>대상을 지정하지 않으면 글로벌 적용</strong></li>
    </ul>
  </li>
  <li><strong>대상 컨트롤러 지정 방법</strong>
    <ul>
      <li>어노테이션 단 → <code class="language-plaintext highlighter-rouge">@ControllerAdvice(annotations = RestController.class)</code></li>
      <li>패키지 단 → <code class="language-plaintext highlighter-rouge">@ControllerAdvice("org.example.controllers")</code></li>
      <li>컨트롤러 단 → <code class="language-plaintext highlighter-rouge">@ControllerAdvice(assignableTypes = {ControllerInterface.class, AbstractController.class})</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">@ExceptionHandler</code> 와 <code class="language-plaintext highlighter-rouge">@ControllerAdvice</code> 를 조합하면 예외를 보다 더 깔끔하게 해결 가능!!</li>
</ul>
:ET