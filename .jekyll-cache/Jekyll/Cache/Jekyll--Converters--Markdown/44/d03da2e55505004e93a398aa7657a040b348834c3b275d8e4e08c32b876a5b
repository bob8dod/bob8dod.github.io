I"v<h2 id="jpa에서의-데이터-상위-타입-분류">JPA에서의 데이터 상위 타입 분류</h2>

<h3 id="entity-type">Entity Type</h3>

<ul>
  <li><strong>Table로도 설정</strong>되는 객체</li>
  <li><code class="language-plaintext highlighter-rouge">@Entity</code> 로 정의되는 객체</li>
  <li><strong>데이터가 변경되도 식별자(PK)로 지속적인 추적 가능</strong></li>
</ul>

<h3 id="값-타입">값 타입</h3>

<ul>
  <li>int, Integer, Long, String 처럼 <strong>단순히 값으로 사용하는 Java 기본 타입 or 객체</strong></li>
  <li><strong>식별자(pk)가 없고 값만 있기에 변경 시 추적 불가 [중요]</strong> → 변경 시 아예 <strong>대체가 되어버림</strong></li>
  <li>ex) Integer 100을 200으로 변경하면 해당 객체의 값이 100에서 200으로 변경 되는 것이 아닌 100을 새로운 Integer 200으로 대체하는 것</li>
</ul>

<h2 id="값-타입-1">값 타입</h2>

<h3 id="값-타입-특징">값 타입 특징</h3>

<ul>
  <li>특징
    <ul>
      <li><strong>생명주기를 엔티티에 의존</strong> 
  → 해당 Entity를 저장하면 같이 저장되고 삭제하면 같이 삭제됨</li>
      <li><strong>값 타입은 공유되면 안됨</strong>
  → 한 Entity의 기본 값을 변경했는데 다른 Entity의 기본 값도 변경되면 안됨! (나쁜 의미의 부수효과) [<strong>독립적</strong>으로 사용해야 됨]</li>
    </ul>
  </li>
  <li>종류
    <ol>
      <li>기본값 타입 (Basic Type)
        <ul>
          <li>Java basic Type (int, double, …)</li>
          <li>래퍼 클래스(Integer, Long)</li>
          <li>String</li>
        </ul>
      </li>
      <li>임베디드 타입 (Enbedded Type, 복합 값 타입)</li>
      <li>컬렉션 값 타입 (Collection Value Type)</li>
    </ol>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nd">@Entity</span>
  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span><span class="o">{</span>
  		<span class="c1">// 식별자 (기본값 타입)</span>
      <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span><span class="o">(</span><span class="n">strategy</span> <span class="o">=</span> <span class="nc">GenerationType</span><span class="o">.</span><span class="na">AUTO</span><span class="o">)</span>
      <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"MEMBER_ID"</span><span class="o">)</span>
      <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>
    
  		<span class="c1">// 1. 기본값 타임</span>
      <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span> 
    
      <span class="nd">@Embedded</span> <span class="c1">// 2. 임베디드 타입</span>
      <span class="kd">private</span> <span class="nc">Address</span> <span class="n">address</span><span class="o">;</span> 
    
      <span class="nd">@ElementCollection</span> <span class="c1">// 3. 컬렉션 값 타입</span>
      <span class="nd">@CollectionTable</span><span class="o">(</span>
              <span class="n">name</span> <span class="o">=</span> <span class="s">"ADDRESS"</span>
              <span class="n">joinColumns</span> <span class="o">=</span> <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"MEMBER_ID"</span><span class="o">)</span>
      <span class="o">)</span>
      <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Address</span><span class="o">&gt;</span> <span class="n">addressHistory</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span> 
  <span class="o">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="기본값-타입">기본값 타입</h3>

<ul>
  <li>특징
    <ul>
      <li><strong>단순히 값으로</strong> 사용하는 Java 기본 타입</li>
      <li>int, Integer, Long, String</li>
    </ul>
  </li>
  <li>주의점 : <strong>기본 값 타입은 절대 공유해선 안됨</strong>
    <ul>
      <li>int, double 같은 기본 타입(primitive type)은 절대 공유가 안되며 공유해선 안됨
        <ul>
          <li>기본 타입(primitive type)은 <strong>항상 값을 복사</strong>함</li>
          <li><code class="language-plaintext highlighter-rouge">int a = 20; int b = a;</code> 라고 할 때, a의 복사된 값이 b에 들어가는 것</li>
          <li>즉, <strong>레퍼런스를 주는 것이 아니라 값을 복제하여 집어 넣음</strong></li>
        </ul>
      </li>
      <li>Integer같은 래퍼 클래스나 String 같은 특수한 클래스는 공유 가능한 객체이지만 공유해서는 안됨! (변경이 안되긴 함)
        <ul>
          <li><code class="language-plaintext highlighter-rouge">Integer a = new Integer(10); Integer b = a;</code> 라고 할 때, a의 <strong>Reference가 b로 넘어가는 것</strong>!</li>
          <li>만약 여기서 b의 값을 변경할 수 있다면, a의 값도 함께 변경됨</li>
          <li>즉, <strong>둘을 공유해서 사용하면 부정적 부수 효과가 일어남! → 공유X</strong></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="임베디드-타입-복합-값-타입">임베디드 타입 (복합 값 타입)</h3>

<ul>
  <li>개념
    <ul>
      <li>사용할 수 있는 기존의 기본 값 타입 이외의 <strong>새로운 값 타입을 직접 정의</strong>할 수 있음 (물론 <strong>Table</strong> 저장 시 직접 정의된 <strong>값 타입 속 기본 값 타입들로 저장</strong> 됨)</li>
      <li>JPA에서는 이를 <strong>임베디드 타입(Embedded Type)</strong>이라고 부름</li>
      <li>이는 주로 기본 값 타입들(int, String, … )을 모아서 만들기에 “<strong>복합 값 타입</strong>” 이라고도 부름</li>
      <li>값 타입이기에 <strong>Entity가 아님!</strong> → <strong>변경 시 추적 불가능! 생명주기가 연결된 Entity를 따름</strong></li>
    </ul>
  </li>
  <li>임베디드 타입이 필요한 상황
    <ul>
      <li>Member Entity 에 다른 Entity에서 중복되며 사용되는 field 들(<strong>공통적인 속성들</strong>)이 있음</li>
      <li>
        <p>이를 통합 시켜 사용하고자 하는 상황 (비지니스적으로도 깔끔해지고, 사용할 수 있는 방향이 다양해짐(다른 Entity에서도 공통적으로 사용할 수 있는 것!))</p>

        <p><img src="%E1%84%80%E1%85%A1%E1%86%B9%20%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%B8%205badbe34fd984acf96e00057a59419d9/Untitled.png" alt="Untitled" /></p>
      </li>
      <li>
        <p>이 상황은 임베디드 타입을 생성하여 구현해 낼 수 있음</p>

        <p><img src="%E1%84%80%E1%85%A1%E1%86%B9%20%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%B8%205badbe34fd984acf96e00057a59419d9/Untitled%201.png" alt="Untitled" /></p>
      </li>
    </ul>
  </li>
  <li>특징
    <ul>
      <li><strong>재사용 가능</strong> (<strong>공통적인 속성을 재사용</strong>하여 계속 깔끔히 사용 가능)</li>
      <li><strong>높은 응집도</strong>
        <ul>
          <li>비지니스적으로 공통적인 속성들을 한데 묶을 수 있음</li>
          <li><strong>해당 값 타입만 사용하는 의미 있는 메소드</strong>를 만들 수 있음 → 임베디드 타입 객체 속 메서드 생성하여 활용 (객체 지향적인 설계)</li>
        </ul>
      </li>
      <li>임베디드 타입은 값 타입(int, String 과 같은 타입이라 생각하면 됨)이기에 <strong>이를 소유한 Entity에 생명주기를 의존</strong></li>
      <li>임베디드 타입의 값이 null 이면 해당 속성들은 모두 null로 저장됨</li>
    </ul>
  </li>
  <li>
    <p>테이블과의 매핑</p>

    <p><img src="%E1%84%80%E1%85%A1%E1%86%B9%20%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%B8%205badbe34fd984acf96e00057a59419d9/Untitled%202.png" alt="Untitled" /></p>

    <ul>
      <li>임베디드 타입을 사용하기 전과 후에 매핑하는 테이블은 같음 → <strong>DB입장에서 기본값 타입으로 사용하든, 임베디드 타입을 사용하든 똑같은 Table로 저장</strong>됨</li>
      <li>즉, Table에는 영향을 주지 않은 채로 Application 단에서는 재사용, 응집도 증가 등 다양한 장점을 얻어낼 수 있음</li>
      <li>객체와 테이블을 아주 세밀하게 매핑하는 것이 가능</li>
      <li>잘 설계한 ORM Application은 매핑한 테이블의 수보다 클래스의 수가 더 많음!</li>
    </ul>
  </li>
  <li>사용법
    <ul>
      <li>
        <p><code class="language-plaintext highlighter-rouge">@Embeddable</code> : 값 타입을 정의하는 곳에 표시</p>

        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nd">@Embeddable</span> <span class="c1">// 값 타입 선언</span>
  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Address</span> <span class="o">{</span>
        
      <span class="kd">private</span> <span class="nc">String</span> <span class="n">city</span><span class="o">;</span>
      <span class="kd">private</span> <span class="nc">String</span> <span class="n">street</span><span class="o">;</span>
      <span class="kd">private</span> <span class="nc">String</span> <span class="n">zipcode</span><span class="o">;</span>
        
      <span class="kd">public</span> <span class="nf">Address</span><span class="o">()</span> <span class="o">{</span>
      <span class="o">}</span>
  		<span class="o">...</span> <span class="c1">// getter setter</span>
  <span class="o">}</span>
</code></pre></div>        </div>

        <ul>
          <li>공통적으로 사용되는 속성들을 한데 묶어서 표현할 수 있음</li>
          <li>이들만을 다루는 메서드 생성 가능</li>
          <li><strong>기본 생성자 필수</strong> → JPA가 해당 Embedded 객체를 생성하여 Entity에 넣어주기 때문</li>
        </ul>
      </li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">@Embedded</code> : 값 타입을 사용하는 곳에 표시</p>

        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// Member Entity</span>
  <span class="nd">@Embedded</span>
  <span class="kd">private</span> <span class="nc">Address</span> <span class="n">address</span><span class="o">;</span>
</code></pre></div>        </div>

        <ul>
          <li>이렇게 되면 Member Entity는 Address Enbedded Type을 가지게 되고, Address의 속성들(city,street, zipcode)을 사용할 수 있게 된 것</li>
          <li>어쨌든 Table은 동일하게 구성됨</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <ul>
      <li>
        <p>연관관계</p>

        <p><img src="%E1%84%80%E1%85%A1%E1%86%B9%20%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%B8%205badbe34fd984acf96e00057a59419d9/Untitled%203.png" alt="Untitled" /></p>

        <ol>
          <li>임베디드 타입이 임베디드 타입을 가질 수 있음</li>
          <li><strong>[중요] 임베디드 타입이 Entity를 가질 수 있음!</strong></li>
        </ol>
      </li>
    </ul>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">@AttributeOverride</code></p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// Member Entity</span>
  <span class="nd">@Embedded</span>
  <span class="kd">private</span> <span class="nc">Address</span> <span class="n">homeAddress</span><span class="o">;</span>
    
  <span class="nd">@Embedded</span>
  <span class="nd">@AttributeOverrides</span><span class="o">({</span>
  		<span class="nd">@AttributeOrverride</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"city"</span><span class="o">,</span>
  								<span class="n">column</span> <span class="o">=</span> <span class="nd">@Column</span><span class="o">(</span><span class="s">"work_city"</span><span class="o">)),</span>
  		<span class="nd">@AttributeOrverride</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"street"</span><span class="o">,</span>
  								<span class="n">column</span> <span class="o">=</span> <span class="nd">@Column</span><span class="o">(</span><span class="s">"work_street"</span><span class="o">)),</span>
  		<span class="o">...</span>
  <span class="o">})</span>
  <span class="kd">private</span> <span class="nc">Address</span> <span class="n">workAddress</span><span class="o">;</span>
</code></pre></div>    </div>

    <ul>
      <li><strong>속성 재정의</strong></li>
      <li><strong>한 엔티티에서 같은 값 타입을 사용</strong>할 때, 컬럼 명 <strong>중복을 방지</strong>하기 위함</li>
      <li>@AttributeOverrides, @AttributeOverride를 사용해서 Col명 속성을 재정의</li>
    </ul>
  </li>
</ul>

<h3 id="값-타입과-불변-객체">값 타입과 불변 객체</h3>

<ul>
  <li>목표
    <ul>
      <li>Integer, String 과 같이 Java에서 제공 하는 기본 값타입들은 부작용(side effect)가 발생하지 않도록 잘 설계되어 있음</li>
      <li>하지만, 임베디드 값 타입과 같이 <strong>직접 값 타입을 생성하여 사용할 때는 이런 부작용(side effect)</strong>에 대해서 직접 생각하고 다루어 <strong>안전하게 설계가 필요</strong></li>
      <li>해당 문제점들을 피하는 방식 학습 필요</li>
    </ul>
  </li>
  <li>
    <p>값 타입 공유 참조 [잘못된 방식]</p>

    <p><img src="%E1%84%80%E1%85%A1%E1%86%B9%20%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%B8%205badbe34fd984acf96e00057a59419d9/Untitled%204.png" alt="Untitled" /></p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nc">Member</span> <span class="n">m1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">();</span>
  <span class="nc">Member</span> <span class="n">m2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">();</span>
  <span class="nc">Address</span> <span class="n">address</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Address</span><span class="o">(</span><span class="s">"old city"</span><span class="o">,</span> <span class="s">"12 street"</span><span class="o">,</span> <span class="s">"12111"</span><span class="o">);</span>
    
  <span class="c1">// 공유 참조</span>
  <span class="n">m1</span><span class="o">.</span><span class="na">setAddress</span><span class="o">(</span><span class="n">address</span><span class="o">);</span>
  <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">m1</span><span class="o">);</span>
  <span class="n">m2</span><span class="o">.</span><span class="na">setAddress</span><span class="o">(</span><span class="n">address</span><span class="o">);</span>
  <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">m2</span><span class="o">);</span>
    
  <span class="n">m1</span><span class="o">.</span><span class="na">getAddress</span><span class="o">().</span><span class="na">setCity</span><span class="o">(</span><span class="s">"New city"</span><span class="o">);</span> <span class="c1">// 변경 -&gt; m2 의 city도 변경됨</span>
</code></pre></div>    </div>

    <ul>
      <li>임베디드 타입을 여러 엔티티에서 공유한 상태</li>
      <li>여기서 해당 임베디드 타입의 값을 변경 → <strong>공유하고 있는 Entity들의 값이 모두 바뀜! (side effect)</strong></li>
      <li>이런 Side Effect로 인해 발생하는 버그는 잡기 굉장히 어려움!</li>
      <li>그렇다고 <strong>객체의 공유 참조는 피할 수 없음</strong></li>
    </ul>
  </li>
  <li>
    <p>값 타입 복사 [올바른 방법]</p>

    <p><img src="%E1%84%80%E1%85%A1%E1%86%B9%20%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%B8%205badbe34fd984acf96e00057a59419d9/Untitled%205.png" alt="Untitled" /></p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nc">Member</span> <span class="n">m1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">();</span>
  <span class="nc">Member</span> <span class="n">m2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">();</span>
  <span class="nc">Address</span> <span class="n">address</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Address</span><span class="o">(</span><span class="s">"old city"</span><span class="o">,</span> <span class="s">"12 street"</span><span class="o">,</span> <span class="s">"12111"</span><span class="o">);</span>
    
  <span class="c1">// 공유 참조</span>
  <span class="n">m1</span><span class="o">.</span><span class="na">setAddress</span><span class="o">(</span><span class="n">address</span><span class="o">);</span>
  <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">m1</span><span class="o">);</span>
  <span class="nc">Addresss</span> <span class="n">copied</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Address</span><span class="o">(</span><span class="n">address</span><span class="o">.</span><span class="na">getCity</span><span class="o">(),</span> <span class="o">...);</span>
  <span class="n">m2</span><span class="o">.</span><span class="na">setAddress</span><span class="o">(</span><span class="n">copied</span><span class="o">);</span>
  <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">m2</span><span class="o">);</span>
    
  <span class="n">m1</span><span class="o">.</span><span class="na">getAddress</span><span class="o">().</span><span class="na">setCity</span><span class="o">(</span><span class="s">"New city"</span><span class="o">);</span> <span class="c1">// 변경 -&gt; m2 의 city가 변경되지 않음</span>
</code></pre></div>    </div>

    <ul>
      <li>값 타입의 실제 인스턴스를 공유하는 것이 아닌</li>
      <li><strong>값을 복사해서 사용</strong> → <strong>부작용(side effect)이 발생하지 않음</strong>.</li>
      <li>말 그대로 <strong>새로운 값 타입을 넣어 주는 것!</strong></li>
    </ul>
  </li>
  <li><strong>불변 객체</strong>
    <ul>
      <li><strong>생성 시점 이후</strong> 절대 <strong>값을 수정/변경 할 수 없는 객체</strong></li>
      <li>객체 타입(직접 생성한 값 타입. ex_임베디드 객체)은 <strong>공유 참조를 막을 수 없음</strong> → 이를 <strong>해결하기 위함이 “불변 객체”</strong></li>
      <li>객체 타입을 수정할 수 없게 만들어 <strong>부작용(side effect)을 원천 차단</strong></li>
      <li><strong>값 타입</strong>은 <strong>불변 객체(immutable object)로 설계</strong>해야 함</li>
      <li>
        <p>불변 객체 설정 방법 : <strong>생성자로만 값을 설정하고 수정자를 만들지 않으면 됨!!!</strong></p>

        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nd">@Embeddable</span> <span class="c1">// 값 타입 선언</span>
  <span class="nd">@Getter</span> <span class="c1">// getter만 열어두고 setter는 열지 않음 -&gt; 불변 객체 설정</span>
  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Address</span> <span class="o">{</span>
  		<span class="o">...</span>
  		<span class="kd">public</span> <span class="nf">Address</span><span class="o">(</span><span class="nc">String</span> <span class="n">city</span><span class="o">,</span> <span class="nc">String</span> <span class="n">street</span><span class="o">,</span> <span class="nc">String</span> <span class="n">zipcode</span><span class="o">)</span> <span class="o">{</span>
  			<span class="o">...</span>
      <span class="o">}</span>
      <span class="kd">public</span> <span class="nf">Address</span><span class="o">()</span> <span class="o">{</span>
      <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div>        </div>
      </li>
      <li>Integer, String과 같은 객체들은 자바에서 기본으로 불변 객체로 설정</li>
    </ul>
  </li>
</ul>

<h3 id="값-타입의-비교">값 타입의 비교</h3>

<ul>
  <li>
    <p>값 타입은 인스턴스(주소)가 달라도 <strong>그 안의 값이 모두 같다면 같은 것</strong>으로 봐야 됨</p>

    <p><code class="language-plaintext highlighter-rouge">int a = 10; int b = 10; a== b</code> → true</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nc">Address</span> <span class="n">a1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Address</span><span class="o">(</span><span class="s">"city1"</span><span class="o">,</span><span class="s">"12street"</span><span class="o">);</span>
  <span class="nc">Address</span> <span class="n">a2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Address</span><span class="o">(</span><span class="s">"city1"</span><span class="o">,</span><span class="s">"12street"</span><span class="o">);</span>
  <span class="n">a1</span> <span class="o">==</span> <span class="n">a2</span> <span class="c1">// 항상 false</span>
  <span class="n">a1</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">a2</span><span class="o">)</span> <span class="c1">// true 로 만들어 줘야 함! -&gt; 값 타입이므로</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>값 타입에서의 비교</p>
    <ul>
      <li><strong>동일성(identity) 비교</strong> : 인스턴스의 <strong>참조 값</strong>을 비교, <code class="language-plaintext highlighter-rouge">==</code> 사용</li>
      <li><strong>동등성(equivalence) 비교</strong> : 인스턴스의 <strong>값</strong>을 비교, <code class="language-plaintext highlighter-rouge">equals()</code> 사용</li>
      <li><strong>값 타입</strong>은 값을 비교해야 되기 때문에 항상 <code class="language-plaintext highlighter-rouge">equals()</code> 를 사용하여 <strong>동등성을 비교</strong>해야 됨</li>
      <li>즉, 값타입의 <code class="language-plaintext highlighter-rouge">equals()</code>메서드를 <strong>적절하게 재정의</strong> 필요 → <strong>모든 필드를 사용</strong>하여</li>
      <li>예시
        <ul>
          <li>
            <p>사용자 정의 값 타입 (임베디드 타입)의 equals(), hashCode() Override를 통해 재정의</p>

            <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nd">@Override</span>
      <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">if</span> <span class="o">(</span><span class="k">this</span> <span class="o">==</span> <span class="n">o</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
          <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">getClass</span><span class="o">()</span> <span class="o">!=</span> <span class="n">o</span><span class="o">.</span><span class="na">getClass</span><span class="o">())</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
          <span class="nc">Address</span> <span class="n">address</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Address</span><span class="o">)</span> <span class="n">o</span><span class="o">;</span>
          <span class="k">return</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">getCity</span><span class="o">(),</span> <span class="n">address</span><span class="o">.</span><span class="na">getCity</span><span class="o">())</span> <span class="o">&amp;&amp;</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">getStreet</span><span class="o">(),</span> <span class="n">address</span><span class="o">.</span><span class="na">getStreet</span><span class="o">())</span> <span class="o">&amp;&amp;</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">getZipcode</span><span class="o">(),</span> <span class="n">address</span><span class="o">.</span><span class="na">getZipcode</span><span class="o">());</span>
      <span class="o">}</span>
            
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
      <span class="k">return</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">hash</span><span class="o">(</span><span class="n">getCity</span><span class="o">(),</span> <span class="n">getStreet</span><span class="o">(),</span> <span class="n">getZipcode</span><span class="o">());</span>
  <span class="o">}</span>
</code></pre></div>            </div>

            <ul>
              <li><code class="language-plaintext highlighter-rouge">equals()</code> 에서 <strong>getter</strong>를 사용하여 속성을 가져오는 것이 좋음 → 프록시 등 나중에 예기치못한 오류를 맞이할 가능성이 큼</li>
            </ul>
          </li>
          <li>이렇게 재정의를 하지 않은 경우에는 <code class="language-plaintext highlighter-rouge">equals()</code> 를 사용하면 false가 반환됨 (<code class="language-plaintext highlighter-rouge">equals()</code> 의 기본은 <code class="language-plaintext highlighter-rouge">==</code> 비교)</li>
          <li>재정의 후 → <strong>값 비교 가능!</strong></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="값-타입-컬렉션">값 타입 컬렉션</h3>

<ul>
  <li>
    <p>개념</p>

    <p><img src="%E1%84%80%E1%85%A1%E1%86%B9%20%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%B8%205badbe34fd984acf96e00057a59419d9/Untitled%206.png" alt="Untitled" /></p>

    <ul>
      <li>값 타입을 하나 이상 저장할 때 사용</li>
      <li><strong>DB는 Collection을 해당 Entity와 같은 Table에 저장할 수 없음</strong></li>
      <li>Collection을 저장하기 위한 <strong>별도의 Table이 필요</strong></li>
      <li>Collection으로 생성된 Table은 <strong>모든 속성이 묶여서 PK가 됨</strong> → 값 타입의 특징 (만약 PK가 하나고 나머지는 그냥 속성값으로 남게 되면 그건 그냥 Entity가 되어버림)</li>
      <li>값 타입 Collection도 당연히 나머지 <strong>값 타입과 같이 동작</strong> → 모든 라이프사이클이 해당 Entity에 의존 (persist, remove 등이 필요 없음) ⇒ <strong>영속성 전이 + 고아 객체 제거 기능을 필수로 가짐</strong></li>
    </ul>
  </li>
  <li>사용
    <ul>
      <li><code class="language-plaintext highlighter-rouge">@ElementCollection</code>, <code class="language-plaintext highlighter-rouge">@CollectionTable</code> 사용</li>
    </ul>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// Member Entity</span>
  <span class="nd">@ElementCollection</span>
  <span class="nd">@CollectionTable</span><span class="o">(</span>
          <span class="n">name</span> <span class="o">=</span> <span class="s">"FAVORITE_FOOD"</span><span class="o">,</span> <span class="c1">// 테이블 명</span>
          <span class="n">joinColumns</span> <span class="o">=</span> <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"MEMBER_ID"</span><span class="o">)</span> <span class="c1">// FK 선택</span>
  <span class="o">)</span>
  <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"FOOD_NAME"</span><span class="o">)</span> <span class="c1">// String 속성 하나이기 때문에 예외적으로 설정 가능</span>
  <span class="kd">private</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">favoriteFoods</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
    
  <span class="nd">@ElementCollection</span>
  <span class="nd">@CollectionTable</span><span class="o">(</span>
          <span class="n">name</span> <span class="o">=</span> <span class="s">"ADDRESS"</span><span class="o">,</span> <span class="c1">// 테이블 명</span>
          <span class="n">joinColumns</span> <span class="o">=</span> <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"MEMBER_ID"</span><span class="o">)</span> <span class="c1">// FK 선택</span>
  <span class="o">)</span>
  <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Address</span><span class="o">&gt;</span> <span class="n">addressHistory</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
</code></pre></div>    </div>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">@ElementCollection</code> : 해당 속성을 <strong>Collection Table로 저장</strong>한다는 것</li>
      <li><code class="language-plaintext highlighter-rouge">@CollectionTable</code> : Collection 은 Table로 저장되기 때문에, 해당 Colleciton Table 설정해주는 것
        <ul>
          <li>name : 테이블 명</li>
          <li>joinColumns : <strong>Table과 매핑할 FK</strong> 선택 및 설정 → 어쨌든 <strong>해당 Entity와 연결</strong>되어야 하므로 <strong>Foriegn Key를 설정</strong>해야됨</li>
        </ul>
      </li>
      <li>저장
        <ul>
          <li>Entity 저장 시 따로 Collection은 persist 할 필요 없음 → <strong>영속성 전이 + 고아 객체 제거 기능</strong>을 필수로 가짐</li>
          <li>
            <p>테이블 저장 확인</p>

            <p><img src="%E1%84%80%E1%85%A1%E1%86%B9%20%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%B8%205badbe34fd984acf96e00057a59419d9/Untitled%207.png" alt="Untitled" /></p>
          </li>
          <li>이런 식으로 Table로 저장되는 것을 확인할 수 있음</li>
        </ul>
      </li>
      <li>조회
        <ul>
          <li>조회 시 같이 한번에 끌어다 오는 것이 아니라 <strong>해당 collection에 접근해야지 실제로 값을 가져옴</strong> → <strong>지연로딩 전략</strong> 사용</li>
        </ul>
      </li>
      <li>수정
        <ul>
          <li>값 타입이기에 따로 저장하거나 그럴 필요 없이 알아서 Entity에 저장됨</li>
          <li>
            <p>Set Collection 수정</p>

            <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">findMember</span><span class="o">.</span><span class="na">getFavoriteFoods</span><span class="o">().</span><span class="na">remove</span><span class="o">(</span><span class="s">"치킨"</span><span class="o">);</span>
  <span class="n">findMember</span><span class="o">.</span><span class="na">getFaveriteFoods</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="s">"짜장면"</span><span class="o">);</span>
</code></pre></div>            </div>

            <ul>
              <li>Set Collection은 수정 가능, But 값 자체를 수정하는 것이 불가 → <strong>제거한 후 새로 넣어주어야 함</strong></li>
            </ul>
          </li>
          <li>
            <p>List Collection 수정</p>

            <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">findMember</span><span class="o">.</span><span class="na">getAddressHistory</span><span class="o">().</span><span class="na">remove</span><span class="o">(</span><span class="k">new</span> <span class="nc">Address</span><span class="o">(...));</span> <span class="c1">// equals() 로 동작</span>
  <span class="n">findMember</span><span class="o">.</span><span class="na">getAddressHistory</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Address</span><span class="o">(...));</span>
</code></pre></div>            </div>

            <ul>
              <li>[중요] 값 타입 List Collection은 <strong>변경 사항이 발생</strong>하면, 관련된 <strong>모든 데이터를 삭제하고 값 타입 컬렉션에 있는 현재 값을 모두 다시 저장</strong>
                <ul>
                  <li>즉, 원하는 Address를 삭제하고 새로운 Address를 넣은 <strong>새로운 Collection이 해당 Entity에 넣어지게 되는 것</strong> → DB query가 날라가는 것을 통해 확인 가능 (Address 전체를 삭제 한 후, 새로운 Address를 저장)</li>
                  <li>이는 값 타입이 엔티티와 다르게 <strong>식별자 개념이 없이 모든 컬럼을 묶어서 PK를 구성하기 때문</strong> → 변경 시 추적이 안되는 이유 (수정하게 되면 그 구성된 Pk가 깨지는 것이니깐!)</li>
                  <li>추가로 Set과는 다르게 <strong>순서값이 존재</strong>하므로! (Set은 순서가 없어서 상관 없음)</li>
                </ul>
              </li>
              <li><strong>[중요]</strong> 고로 List Collection은 값 타입 Collection 보다는 <code class="language-plaintext highlighter-rouge">@OneToMany</code>로 연결해주는 것이 낫다! → 즉, <strong>자체적인 PK를 가지게 하여 추적할 수 있게하는 것</strong></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>값 타입 컬렉션 대안</strong>
    <ul>
      <li>실무에서는 상황에 따라 <strong>값 타입 Collection 대신 일대다 관계를 고려</strong></li>
      <li>일대다 관계만을 위한 Entity를 만들고, 여기서 값 타입을 사용하는 것 (PK가 딸린 Collection 느낌)</li>
      <li><strong>[중요] 영속성 전이 + 고아 객체 제거 기능을 이용해서 값 타입 Collection 같이 사용</strong>하는 것!</li>
    </ul>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nd">@Entity</span>
  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">AddressEntity</span> <span class="o">{</span>
      <span class="nd">@Id</span>
      <span class="nd">@GeneratedValue</span>
      <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>
    
      <span class="nd">@Embedded</span>
      <span class="kd">private</span> <span class="nc">Address</span> <span class="n">address</span><span class="o">;</span>
  <span class="o">}</span>
</code></pre></div>    </div>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// Member Entity (@ElementCollection -&gt; @OneToMany)</span>
  <span class="nd">@OneToMany</span><span class="o">(</span><span class="n">cascade</span> <span class="o">=</span> <span class="nc">CascadeType</span><span class="o">.</span><span class="na">ALL</span><span class="o">,</span> <span class="n">orphanRemoval</span> <span class="o">=</span> <span class="kc">true</span><span class="o">)</span> <span class="c1">// </span>
  <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"MEMBER_ID"</span><span class="o">)</span>
  <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">AddressEntity</span><span class="o">&gt;</span> <span class="n">addressHistories</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
</code></pre></div>    </div>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">@OneToMany</code> 에서 <code class="language-plaintext highlighter-rouge">cascade = CascadeType.ALL, orphanRemoval = true</code> 를 통해서 더 <strong>Collection 의 느낌으로 사용</strong>할 수 있음</li>
      <li>이렇게 Collection을 일대다 관계로 풀어내게 되면 활용할 수 있는 것들이 훨씬 많아짐 (전용 Method 추가 등)</li>
    </ul>
  </li>
</ul>

<aside>
⚠️ **값 타입 사용 시 유의할 점**

- 값 타입은 정말 **값 타입이라고 판단 될 때만 사용**해야됨
- Entity와 값 타입을 혼동해서 사용하면 안됨! 명확한 구분이 필요!
- **식별자가 필요하고, 지속해서 값을 추적하며 해당 값을 자주 사용하게 된다**면 값 타입이 아닌 **Entity로 사용**해야 됨!
</aside>
:ET