I"X<h2 id="chapter-7-웹-계층-개발">Chapter 7 [웹 계층 개발]</h2>

<ul>
  <li>Main 화면
    <ul>
      <li>Controller (HomeController), home.html,</li>
      <li>클라이언트의 요청을 1차적으로 받는 곳.</li>
      <li>클라이언트가 요청을 하면, 해당 요청을 TomCat 내장 서버가 이를 받아오고 Spring Container 속 Controller들 중 이 요청에  Mapping 하는 것이 있는지 확인함.</li>
      <li>Main home 화면 매핑 → <code class="language-plaintext highlighter-rouge">String home()</code>
        <ul>
          <li><code class="language-plaintext highlighter-rouge">@RequestMapping("/")</code> : main이 되는 화면의 Get 요청에 mapping</li>
          <li><code class="language-plaintext highlighter-rouge">return "home";</code> : 스프링 부트 thymeleaf viewName 맵핑 (resources:templates/ +{<strong>ViewName</strong>}+ .html.) 에 따라 resources의 templates의 home.html 을 HTTP 통신으로 Client에게 넘겨줌.</li>
        </ul>
      </li>
      <li>home.html
        <ul>
          <li>thymleaf 문법을 사용하며 header.html, bodyHeader.html, footer.html을 include하고 있음. (즉, include style. 이는 hierarchical style로 구성할 수도 있음)</li>
          <li><code class="language-plaintext highlighter-rouge">&lt;html xmlns:th="http://www.thymeleaf.org"&gt;</code></li>
          <li><code class="language-plaintext highlighter-rouge">&lt;head th:replace="fragments/header :: header"&gt;</code></li>
          <li><code class="language-plaintext highlighter-rouge">&lt;div th:replace="fragments/bodyHeader :: bodyHeader"/&gt;</code></li>
          <li><code class="language-plaintext highlighter-rouge">&lt;div th:replace="fragments/footer :: footer"/&gt;</code></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>회원 등록 화면
    <ul>
      <li>회원 등록 Form → <code class="language-plaintext highlighter-rouge">class MemberForm</code>
        <ul>
          <li><strong>DTO : Data Transaction Object</strong> 로직을 가지지 않는 데이터 객체이고 getter/setter 메소드만 가진 클래스. 즉, data를 옮기는 역할만 하는 객체</li>
          <li>화면에서 name, address(city, street, zipcode) 를 받아오는 역할</li>
          <li><code class="language-plaintext highlighter-rouge">private String name;</code> ← <code class="language-plaintext highlighter-rouge">@NotEmpty(message = "이름은 필수로 입력하셔야 됩니다.")</code> ⇒ <code class="language-plaintext highlighter-rouge">@NotEmpty</code> : validation 역할. 비어있으면 안되는 변수로 설정. 비어 있으면 해당 message를 날림.</li>
        </ul>

        <aside>
        
💡 <strong> memberForm을 쓰는 이유 </strong> (그냥 member로 입력된 값을 객체 자체로 받아오면 안됨?)
  <ul>
  <li> Entity를 web상에서 왔다갔다하는 form 데이터로 사용하면 화면에서 요구하는 데이터와 실제 Entity가 요구하는 값들이 안맞을 수도 있고 이걸 억지로 맞춰야하는 번거러움이 존재하기 때문 </li>
  <li> 또한 Validation을 사용하려면 그냥 form을 만들어서 그 form으로 데이터를 주고 받는 것이 남. </li>
  <li> 실무에서는 실제 화면에서 받는 데이터들은 훨씬 복잡하기 때문!! </li>
  <li> JPA를 사용한다면, Entity는 최대한 순수하게 유지해야 됨!!!! 
  &lt;/ul&gt;
  &lt;/aside&gt;

</li></ul></aside>
      </li>
      <li>(Controller) 회원 등록 시 열어보는 용도 → Get → <code class="language-plaintext highlighter-rouge">String register(Model model)</code>
        <ul>
          <li><code class="language-plaintext highlighter-rouge">@GetMapping("/members/new")</code></li>
          <li><code class="language-plaintext highlighter-rouge">Model model</code>은 html로 넘어가 thymeleaf와 상호작용하는 놈. 즉, html에 데이터를 넘겨주는 역할. (model에 속성으로 데이터를 넣어주면 thymeleaf를 통해 html에서 받아온 데이터를 사용할 수 있음.)</li>
          <li><code class="language-plaintext highlighter-rouge">model.addAttribute("memberForm",new MemberForm());</code> : 빈 껍데기의 MemberForm 객체를 가지고 감
            <ul>
              <li>Validation 가능해짐.</li>
              <li>입력된 정보를 mebmerform을 통해 PostMapping으로 보내줄 수 있음. (즉, 객체로 보내지는 것)</li>
            </ul>
          </li>
          <li><code class="language-plaintext highlighter-rouge">return "members/createMemberForm";</code> : resources의 templates의 members에서 createMemberForm.html을 HTTP 통신으로 Client에게 보냄.</li>
        </ul>
      </li>
      <li>(Controller) 회원 정보 작성 후 제출, 등록하는 용도 → Post → <code class="language-plaintext highlighter-rouge">String join(@Valid MemberForm memberForm, BindingResult result)</code>
        <ul>
          <li><code class="language-plaintext highlighter-rouge">memberForm</code> : Get에서 담겨 보냈던 등록 Form으로 Post하면 해당 Form 객체에 정보가 담긴 채 Postmapping으로 오게 됨. (<code class="language-plaintext highlighter-rouge">@Valid</code> 를 통해 내가 해당 form에서 설정한 필수 값인 name이 담겨 있는지 체크 가능. 즉, 없다면 Error(오류화면)를 발생 시킬 수 있게 됨.)</li>
          <li><code class="language-plaintext highlighter-rouge">BindingResult result</code> : 오류화면으로 넘어가지않고, 그 값이 없는 상태의 error form자체를 그냥 받아와줌. 즉, 오류가 BindingResult에 담겨짐. 즉, 어떤 것이 Error인지 아는 상태가 되며, 그 오류를 담은 상태로 하위 코드들이 실행 되는 것. (결과를 바인딩한다.)</li>
          <li><code class="language-plaintext highlighter-rouge">if (result.hasErrors()){ return "members/createMemberForm";}</code> : 그 result에 error가 담겨 있다면, MemberFrom, BindingResult를 담아서 다시 creatememberForm으로 넘김. 그럼 방금 담겨 있던 정보들과 name 자체에 error가 발생했다는 것을 아는 상태로 넘어가는 것. → 이를 thymeleaf를 통해 이벤트를 생성할 수 있음. (-&gt; spring과 thymleaf가 연동(integration)되어 있기에 가능한 것)</li>
          <li><code class="language-plaintext highlighter-rouge">memberService.join(member);</code> : 에러가 발생하지 않았다면, Address를 저장하고 Member를 저장.</li>
          <li><code class="language-plaintext highlighter-rouge">return "redirect:/";</code> : 재로딩하지 않고 다시 home으로 돌아감</li>
          <li>html에서의 thymeleaf는 생략.</li>
        </ul>

        <aside>
  💡 이런 Error 검출같은 것들과 같은 부가적인 기능은 Thymeleaf + Spring Docs를 통해서 원하는 기능을 찾아 쓰면됨 (굉장히 잘 나와 있음) [[Docs]](https://www.thymeleaf.org/doc/tutorials/3.0/thymeleafspring.html)

  </aside>
      </li>
    </ul>
  </li>
  <li>회원 조회 화면
    <ul>
      <li>(Controller) 회원 조회 → <code class="language-plaintext highlighter-rouge">String list(Model model)</code>
        <ul>
          <li><code class="language-plaintext highlighter-rouge">@GetMapping("/members")</code></li>
          <li><code class="language-plaintext highlighter-rouge">List&lt;Member&gt; members = memberService.findMembers();</code> : memberService (비지니스 로직) 을 통해 전체 회원 조회.</li>
          <li><code class="language-plaintext highlighter-rouge">model.addAttribute("members", members);</code> : html에 넘겨주는 model에 members list를 속성에 추가하여 넘겨줌.</li>
          <li><code class="language-plaintext highlighter-rouge">return "members/memberList";</code> : members의 memberList.html에 model을 넘겨주고 이를 바탕으로 해당 html을 Client에게 넘겨줌.</li>
        </ul>

        <aside>
  💡 이 또한 사실 DTO를 통해 넘겨주는 것이 좋음. template 엔진에게 Etity를 넘기는 것은 괜찮다고 해도, 만약 API로 데이터를 넘긴다면 절대 Entity를 사용하지말고 DTO를 사용해야됨.

  </aside>
      </li>
    </ul>
  </li>
</ul>

<hr />

<ul>
  <li>상품 등록 및 조회
    <ul>
      <li>회원 등록 및 조회와 똑같은 로직으로 진행.
        <ul>
          <li>MemberForm → BookForm (수정을 위해 id를 추가한 form 생성)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>상품 수정 <strong>[중요!]</strong>
    <ul>
      <li>수정 (Get) → <code class="language-plaintext highlighter-rouge">String updateItemForm(@PathVariable("itemId") Long itemId, Model model)</code>
        <ul>
          <li><code class="language-plaintext highlighter-rouge">@GetMapping("/items/{itemId}/edit")</code> : get url 자체에 변수를 넣어준 것.</li>
          <li>수정버튼을 누르게 되면 해당 item의 id가 url에 실리고 그 id를 바탕으로  DB에서 em을 통해 해당 객체를 가져오게 됨 → 그 후, 객체의 정보를 form에 옮긴 후 이를 화면에 출력.</li>
          <li><code class="language-plaintext highlighter-rouge">@PathVariable("itemId") Long itemId</code> : url에 담긴 변수를 itemId에 받아줌.</li>
          <li><code class="language-plaintext highlighter-rouge">Book item = (Book) itemService.findOne(itemId);</code> : 그 id를 바탕으로  DB에서 em을 통해 해당 객체를 가져오게 됨</li>
          <li><code class="language-plaintext highlighter-rouge">BookForm form = new BookForm();</code> <code class="language-plaintext highlighter-rouge">from.set(item.get())...</code> : 객체의 정보를 form에 옮긴 후</li>
          <li><code class="language-plaintext highlighter-rouge">model.addAttribute("form", form);</code> : 이를 화면에 출력.</li>
        </ul>
      </li>
      <li>수정 (Post) → <code class="language-plaintext highlighter-rouge">String updateItem(@PathVariable("itemId") Long itemId, @ModelAttribute("form") BookForm form</code>
        <ul>
          <li><code class="language-plaintext highlighter-rouge">@PostMapping("/items/{itemId}/edit")</code> : get url 자체에 변수를 넣어준 것.</li>
          <li>여기선 사실 PathVariable은 필요없음. → BookForm을 통해 id를 받아왔으므로.</li>
          <li>받아온 form를 통해 새로운 Book Entity를 생성해 준 후 itemService를 통해 저장하면 됨.</li>
          <li><code class="language-plaintext highlighter-rouge">Book book = new Book();</code> : 새로운 Book Entity를 생성 (수정하려고 하는 item의 id와 똑같은 id를 가지고 있는 book entity 생성)</li>
          <li><code class="language-plaintext highlighter-rouge">book.set(form.get())...</code> : 받아온 form의 정보를 새로운 Entity에 심어줌</li>
          <li><code class="language-plaintext highlighter-rouge">itemService.saveItem(book);</code> : 해당 Entity 저장.
            <ul>
              <li>여기서 saveItem(저장 로직 method)를 보면 id가 있을 때와 없을 때를 구분지어 저장함.</li>
              <li>id가 없을 때 → <code class="language-plaintext highlighter-rouge">em.persist(item)</code> (즉, 새로 저장되는 Entity)</li>
              <li><strong>[중요!]</strong> id가 있을 때  <em>**</em>→  <code class="language-plaintext highlighter-rouge">em.merge(item)</code> (즉, 수정된 Entity는 병합 진행! merge는 덮어씌워주는 개념. but 실무에서 잘 안씀. → 변경하지 않은 값들에 대해서도 덮어씌어지며 이상하게 변할 수 있기 때문)</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>변경감지 vs merge
    <ul>
      <li>공통점 : 어쨌든 변경감지를 통해 Update를 진행</li>
      <li>차이점 : 변경감지는 내가 원하는 값들만을 수정할 수 있지만, merge는 선택권없이 모든 값들을 수정(병합)함. → 변경감지를 쓰는 이유</li>
      <li>merge → <code class="language-plaintext highlighter-rouge">em.merge()</code>
        <ul>
          <li>위에서 진행한 로직 그대로 사용할 경우의 상황</li>
          <li>즉, 준영속 상태의 엔티티를 영속 상태로 변경할 때 사용하는 기능</li>
          <li>준영속 엔티티 : 영속성 컨텍스트가 더는 관리하지 않는 엔티티.
            <ul>
              <li>위에서 진행한 로직을 보면, Book Entity를 새로 생성하고 Id 등 기존 정보들의 수정본을 심어줬음. 이러한 객체가 바로 준영속 Entity.</li>
              <li>em으로 가져온 것이 아니기에 영속 Entity가 아니지만, id는 부여되어 id를 통해 em이 DB에서 영속 Entity를 찾아올 수 있기에 준영속 엔티티라고 불림.</li>
            </ul>
          </li>
          <li>
            <p>병합시 동작 방식을 간단히 정리</p>

            <p><img src="/images/posts/post-220316/Untitled 9.png" alt="" /></p>

            <ol>
              <li>준영속 엔티티의 식별자 값으로 영속 엔티티를 조회</li>
              <li>영속 엔티티의 값을 준영속 엔티티의 값으로 <strong>모두</strong> 교체 (병합)</li>
              <li>트랜잭션 커밋 시점에 변경 감지 기능이 동작해서 데이터베이스에 UPDATE SQL이 실행</li>
            </ol>
          </li>
        </ul>
      </li>
      <li>변경감지
        <ul>
          <li>영속성 컨텍스트에서 엔티티를 다시 조회한 후에 데이터를 수정하는 방법 (즉, em을 통해 Entity를 가져와 영속성 컨텍스트에 올리고, 그 상태에서 set을 통해 데이터를 수정)</li>
          <li>트랜잭션 안에서 엔티티를 다시 조회 후 변경 → 트랜잭션 커밋 시점에 <strong>변경 감지(Dirty Checking)</strong>이 동작해서 데이터베이스에 UPDATE SQL 실행 ⇒ 즉, 따로 persist를 하지 않아도 됨. (이미 영속성 컨텍스트 안에 있기에)</li>
          <li><code class="language-plaintext highlighter-rouge">itemService.updateItem(itemId, form.getName(), form.getPrice(), form.getStockQuantity());</code></li>
        </ul>

        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nd">@Transactional</span> <span class="c1">// merge는 사실 이 변경감지 코드와 동일하게 동작함. 단지 merge하나만 적어주면 그 과정을 알아서 진행 (but, 모두 변경)</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">updateItem</span><span class="o">(</span><span class="nc">Long</span> <span class="n">itemId</span><span class="o">,</span> <span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">price</span><span class="o">,</span> <span class="kt">int</span> <span class="n">quantity</span><span class="o">){</span> <span class="c1">// merge가 아닌 변경감지로 저장하는 것. -&gt; 영속성인 객체를 가져와서 context에 올리는 것</span>
      <span class="nc">Item</span> <span class="n">findItem</span> <span class="o">=</span> <span class="n">itemRepository</span><span class="o">.</span><span class="na">findOne</span><span class="o">(</span><span class="n">itemId</span><span class="o">);</span>
      <span class="n">findItem</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="n">name</span><span class="o">);</span> <span class="c1">// setter 없이 Entity안에서 직접 수정이 일어나도록 메서드를 짜는 게 더 좋은 코딩</span>
      <span class="n">findItem</span><span class="o">.</span><span class="na">setPrice</span><span class="o">(</span><span class="n">price</span><span class="o">);</span>
      <span class="n">findItem</span><span class="o">.</span><span class="na">setStockQuantity</span><span class="o">(</span><span class="n">quantity</span><span class="o">);</span>
      <span class="c1">// 영속성 객체이기에 따로 em을 이용해 persist할 필요가 없음. -&gt; 변경감지를 통해 자동으로 update</span>
  <span class="o">}</span> <span class="c1">// 해당 Transactional이 끝나고 commit 시점에 자동으로 변경사항에 대한 query를 날려주는 것.</span>
</code></pre></div>        </div>
      </li>
    </ul>
    <aside>
    
💡 <strong> [참고] </strong> <br /> 실무에서는 보통 업데이트 기능이 매우 재한적이다. 그런데 병합은 모든 필드를 변경해버리고, 데이터가 없으면 null 로 업데이트 해버린다. 병합을 사용하면서 이 문제를 해결하려면, 변경 폼 화면에서 모든 데이터를 항상 유지해야 한다. 실무에서는 보통 변경가능한 데이터만 노출하기 때문에, 병합을 사용하는 것이 오히려 번거롭다. 즉, <strong> 엔티티를 변경할 때는 항상 변경 감지를 사용해야 됨.</strong>

  </aside>

    <aside>
    
💡 <strong> [참고] </strong> <br />
  <ul>
  <li> 컨트롤러에서 어설프게 엔티티를 생성하지 마라.</li>
  <li> 트랜잭션이 있는 서비스 계층에 식별자( id )와 변경할 데이터를 명확하게 전달하라.(파라미터 or 파라미터가 많으면 dto를 통해)</li>
  <li> <strong>트랜잭션</strong>이 있는 서비스 계층에서 영속 상태의 <strong> 엔티티를 조회</strong>하고, <strong>엔티티의 데이터를 직접 변경</strong>하라.</li>
  <li> 트랜잭션 커밋 시점에 <strong>변경 감지(dirty checking)</strong>가 실행.</li>
  </ul>
  </aside>
  </li>
  <li>주문 (상품 주문)
    <ul>
      <li>Order Entity는 앞선 도메인 개발에서 알 수 있듯이 member와 item등 여러 연관관계를 가지고 있기에 member,item service의 DI를 받아야 됨.</li>
      <li>주문 등록
        <ul>
          <li>(Controller) 주문 페이지 → Get → <code class="language-plaintext highlighter-rouge">String createForm(Model model)</code>
            <ul>
              <li><code class="language-plaintext highlighter-rouge">@GetMapping("/order")</code></li>
              <li>멤버 선택 및 상품 선택을 위해 모든 멤버와 상품을 불러들임. → <code class="language-plaintext highlighter-rouge">List&lt;Member&gt; members = memberService.findMembers();</code> , <code class="language-plaintext highlighter-rouge">List&lt;Item&gt; items = itemService.findAll();</code></li>
              <li><code class="language-plaintext highlighter-rouge">model.addAttribute("members", members);</code>, <code class="language-plaintext highlighter-rouge">model.addAttribute("items", items);</code></li>
              <li><code class="language-plaintext highlighter-rouge">return "order/orderForm";</code></li>
            </ul>
          </li>
          <li>
            <p>(Controller) 주문 등록 → Post →</p>

            <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nd">@PostMapping</span><span class="o">(</span><span class="s">"/order"</span><span class="o">)</span>
  <span class="kd">public</span> <span class="nc">String</span> <span class="nf">order</span><span class="o">(</span><span class="nd">@RequestParam</span><span class="o">(</span><span class="s">"memberId"</span><span class="o">)</span> <span class="nc">Long</span> <span class="n">memberId</span><span class="o">,</span>
  	                  <span class="nd">@RequestParam</span><span class="o">(</span><span class="s">"itemId"</span><span class="o">)</span> <span class="nc">Long</span> <span class="n">itemId</span><span class="o">,</span>
  	                  <span class="nd">@RequestParam</span><span class="o">(</span><span class="s">"count"</span><span class="o">)</span> <span class="kt">int</span> <span class="n">count</span><span class="o">){</span>
  	  <span class="n">orderService</span><span class="o">.</span><span class="na">order</span><span class="o">(</span><span class="n">memberId</span><span class="o">,</span> <span class="n">itemId</span><span class="o">,</span> <span class="n">count</span><span class="o">);</span>
  	  <span class="k">return</span> <span class="s">"redirect:/orders"</span><span class="o">;</span>
  <span class="o">}</span>
</code></pre></div>            </div>

            <ul>
              <li>주문 등록 시 html을 통해 각 멤버와 상품의 id를 받아 와줌 (+ 주문 수량)</li>
              <li>이를 바탕으로 Order Entity를 생성 (생성메서드 + 연관관계 메서드를 통해 Entity를 생성)</li>
              <li>이때 중요한 것은 Entity 자체를 method에 보내주는 것이 아닌 식별자를 보내 줌으로 써 Service 내에서 Entity를 다룰 수 있도록 함. (즉, Transactional 안에서 Entity를 다루게 하는 것) → Entity는 Controller 보다는 Transactional이 있는 Service에서 다루는 것이 Best!!</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>주문 조회 및 취소
        <ul>
          <li>주문 조회 → Get → <code class="language-plaintext highlighter-rouge">String orderList(OrderSearch orderSearch, Model model)</code>
            <ul>
              <li><code class="language-plaintext highlighter-rouge">OrderSearch</code> 는 MemberForm과 같이 web상에서 입력되는 값을 객체로 받아드려오는 것.</li>
              <li>그 OrderSearch의 값들을 통해 동적쿼리를 통해 해당 조건에 맞는 Order들을 불러옴 → <code class="language-plaintext highlighter-rouge">List&lt;Order&gt; orders = orderService.findOrders(orderSearch);</code> (findOrders는 <code class="language-plaintext highlighter-rouge">findAllByCriteria</code>를 통해 동적쿼리 실행.)</li>
            </ul>
          </li>
          <li>주문 취소 → Post → <code class="language-plaintext highlighter-rouge">String cancelOrder(Long orderId)</code>
            <ul>
              <li>주문 List에서 취소 버튼을 누르면 작동</li>
              <li><code class="language-plaintext highlighter-rouge">@PostMapping("/orders/{orderId}/cancel")</code> → 얘 또한 식별자 값을 받아와 Service에서 취소 진행. (Transactional 안에서 값 변경 → 변경 감지 가능!) → <code class="language-plaintext highlighter-rouge">orderService.cancelOrder(orderId);</code></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
:ET