I"E<h2 id="chapter-1"><strong>Chapter 1</strong></h2>

<ul>
  <li><strong>프로젝트 생성</strong>
    <ol>
      <li>Maven Project vs Gradle Project
        <ul>
          <li>필요한 라이브러리를 땡겨 오고 build하는 것 까지 관리해주는 Tool!</li>
          <li>즉,  의존관계를 관리. 해당 라이브러리에 필요한 의존관계를 자동으로 설치해주고 설정해주는 것!</li>
          <li>요즘 거의 대부분이 Gradle Project로 Spring boot 프로젝트를 생성함</li>
        </ul>
      </li>
      <li>Spring Boot Version
        <ul>
          <li>SNAPSHOT, M1 같은 미정식 버전을 제외하고 최신 버전을 사용</li>
        </ul>
      </li>
      <li>Dependecies
        <ul>
          <li>프로젝트를 생성할 것인데, 어떤 라이브러리들을 땡겨 쓸거냐. 즉, 초기 라이브러리를 어떤 것들로 쓸것이냐의 설정</li>
          <li>Web 프로젝트를 만들기에 spring web 선택 /  MVC에 이용 되는 템플릿 엔진 <strong>Thymeleaf</strong> 선택 (html에서 thymeleaf를 통해 백엔드의 데이터를 주고 받을 수 있음, 다양한 템플릿 엔진 존재, 때에 따라 선택하면 됨)</li>
        </ul>
      </li>
    </ol>
  </li>
  <li><strong>프로젝트 실행</strong>
    <ul>
      <li>기본 메인 클래스 실행 (main/java/ … /<code class="language-plaintext highlighter-rouge">SemogongApplication</code>)</li>
      <li><a href="http://localhost:8080/">http://localhost:8080</a> 로 접속</li>
      <li>실행 속도 높이기
Preferences → Build, Execution, Deployment → Build Tools → Gradle</li>
      <li>Build and run using: Gradle IntelliJ IDEA</li>
      <li>
        <p>Run tests using: Gradle IntelliJ IDEA</p>
      </li>
      <li>빌드하고 실행하기 (명령 프롬프트(cmd)로 진행, Cloud Server에 올릴때)
        <ol>
          <li>해당 프로젝트 경로로 이동</li>
          <li>gradlew build → 현재 spring boot application을 build</li>
          <li>cd build/libs → 빌드된 java 파일 저장 위치로 이동</li>
          <li>java -jar hello-spring-0.0.1-SNAPSHOT.jar → 빌드된 spring boot application java 파일 실행. 즉, 어플리케이션 가동</li>
          <li>실행 확인 → <a href="http://localhost:8080/">http://localhost:8080/</a> or domain</li>
        </ol>
      </li>
    </ul>
  </li>
  <li><strong>Static vs MVC+Template Engine(Thymeleaf) vs API</strong>
    <ul>
      <li>Static
        <ul>
          <li>스프링 부트 정적 컨텐츠 기능</li>
          <li>static/index.html 을 올려두면 Welcome page 기능을 제공 → 가장 메인 화면</li>
        </ul>
      </li>
      <li>MVC+Template Engine(Thymeleaf)
        <ul>
          <li>MVC(Model, Veiw, Controller)
            <ul>
              <li>사용자 인터페이스, 데이터 및 논리 제어를 구현하는데 널리 사용되는 소프트웨어 디자인 패턴</li>
              <li>요청이 들어오면 그 요청을 내장 톰켓 서버에서 받아서 스프링 컨테이너 속 Controller에 해당 요청 method가 있는지 확인 후 그 method가 반환하는 template html에 설정한 Model을 실어 viewResolver에게 보내줌. 그럼 viewResolver는 반환된 html에 Model을 보내주며 Thymleaf 템플릿 엔진으로 Model의 속성을 처리해주며 html을 HTTP로 보냄</li>
            </ul>
          </li>
          <li>@GetMapping(” ”) 사용. 컨테이너에서 해당 요청을 찾을 수 있도록</li>
        </ul>
      </li>
      <li>API : Application Programming Interface
        <ul>
          <li>Application Programming Interface :  컴퓨터나 소프트웨어를 서로 연결. 문자나 객체(JSON)를 반환</li>
          <li>@ResponseBody 를 사용하면 뷰 리졸버( viewResolver )를 사용하지 않고 HTTP의 BODY에 문자 내용 or 객체(JSON)를 직접 반환</li>
          <li>객체를 반환하면 객체가 JSON으로 변환됨</li>
          <li>@ResponseBody 사용 원리
            <ul>
              <li>HTTP의 BODY에 문자 내용을 직접 반환</li>
              <li>viewResolver 대신에 HttpMessageConverter 가 동작</li>
              <li>기본 문자처리: StringHttpMessageConverter
  기본 객체처리: MappingJackson2HttpMessageConverter</li>
              <li>byte 처리 등등 기타 여러 HttpMessageConverter가 기본으로 등록되어 있음</li>
            </ul>

            <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  참고: 클라이언트의 HTTP Accept 해더와 서버의 컨트롤러 반환 타입 정보 둘을 조합해서
  HttpMessageConverter 가 선택된다.
</code></pre></div>            </div>

            <p><img src="/images/posts/post0/0.png" alt="" /></p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>일반적인 백엔드 개발</strong>
    <ul>
      <li>비지니스 요구사항 정리
<img src="/images/posts/post0/1.png" alt="" /></li>
    </ul>

    <ol>
      <li>컨트롤러 : 웹 MVC에서 Controller 역할
        <ul>
          <li>HTTP 요청에 따른 정해진 작업을 실행하기 위한 컨트롤러.</li>
          <li>model을 얹은 html을 반환 하거나 API(문자, 객체_Json을 반환))</li>
        </ul>
      </li>
      <li>서비스 : 핵심 비지니스 로직 구현. (ex. 회원 가입 or 회원 조회, … )
        <ul>
          <li>요청에 따른 컨트롤러의 선택을 받으면 해당 로직을 실행.</li>
          <li>보통 해당 서비스의 로직에 따라 repository를 통해 도메인을 관리</li>
        </ul>
      </li>
      <li>리포지토리 : 데이터베이스에 접근, 도메인 객체를 DB에 저장하고 관리함.
        <ul>
          <li>Interface를 통해 상황에 따른 다양한 DB server에 대한 다형성을 제공</li>
          <li>아직 데이터 저장소가 선정되지 않아서, 우선 인터페이스로 구현 클래스를 변경할 수 있도록 설계</li>
          <li>데이터 저장소는 RDB, NoSQL 등등 다양한 저장소를 고민중인 상황으로 가정</li>
          <li>개발을 진행하기 위해서 초기 개발 단계에서는 구현체로 가벼운 메모리 기반의 데이터 저장소 사용</li>
        </ul>
      </li>
      <li>도메인 : 비지니스 도메인 객체
        <ul>
          <li>(ex. 회원 객체, 게시물 객체, 댓글 객체, …)</li>
          <li>주로 데이터베이스에 저장하고 관리됨</li>
        </ul>
      </li>
    </ol>

    <ul>
      <li>테스트 케이스
        <ul>
          <li>단순 테스트 (자바 자체로의 Test)
            <ul>
              <li>스프링에 올려 Test를 진행하는 것이 아닌, 자바 코드 자체로의 테스트. 즉, Spring Boot는 실행되지 않음, 물론 DB도 연결되지 않음.</li>
              <li>개발한 기능을 실행해서 테스트 할 때 자바의 main 메서드를 통해서 실행하거나, 웹 애플리케이션의 컨트롤러를 통해서 해당 기능을 실행한다. 하지만 이러한 방법은 준비하고 실행하는데 오래 걸리고, 반복 실행하기 어렵고 여러 테스트를 한번에 실행하기 어렵다는 단점이 있다. 그래서 자바는 <strong>JUnit이라는 프레임워크로 테스트를 실행</strong>해서 이러한 문제를 해결</li>
              <li>해당 class에서 ctrl + alt + T 를 통해 자동으로 Test Case 생성 가능</li>
              <li>given / when(what) / then 의 구조로 짜야됨!
                <ul>
                  <li>“주어진 것들이 무엇이고 / 이들을 통해 언제 무엇을 할것이며 / 그 결과 어떤 것을 test할 것이냐!” 의 구조</li>
                </ul>
              </li>
              <li>@AfterEach : 테스트가 종료될 때 마다 이 기능을 실행. ex) 메모리 DB에 저장된 데이터를 삭제</li>
              <li>@BeforeEach :  각 테스트 실행 전에 호출된다. 테스트가 서로 영향이 없도록 항상 새로운 객체를 생성하고, 의존관계도 새로 맺어준다.</li>
              <li><strong>!!</strong> 테스트는 각각 <strong>독립적으로 실행</strong>되어야 한다. 테스트 순서에 의존관계가 있는 것은 좋은 테스트가 아니다</li>
              <li>Test에서 자주 사용되는 것</li>
            </ul>

            <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">assertj</span><span class="o">.</span><span class="na">core</span><span class="o">.</span><span class="na">api</span><span class="o">.</span><span class="na">Assertions</span><span class="o">.*;</span>
  <span class="n">assertThat</span><span class="o">(</span><span class="n">result</span><span class="o">).</span><span class="na">isEqualTo</span><span class="o">(</span><span class="n">member</span><span class="o">);</span> <span class="c1">// 동일한 멤버면 오류발생 X. 동일하지 않으면 오류 발생 → Test 미통과!</span>
  <span class="n">assertThrows</span><span class="o">(</span><span class="nc">IllegalStateException</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="n">memberService</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="n">member2</span><span class="o">));</span> <span class="c1">// 뒤의 로직을 실행했을 때 해당 오류가 발생하지 않는다면 미통과! 오류가 발생하면 통과! → 헷갈릴 수 있음 주의하길!</span>
</code></pre></div>            </div>
          </li>
          <li>스프링 통합 테스트 (테스트를 스프링에서 진행)
            <ul>
              <li>스프링 위에서 테스트를 진행하는 것. 즉, 스프링 컨테이너와 DB까지 연결하여 통합적으로 테스트를 진행</li>
              <li>@SpringBootTest : 스프링 컨테이너와 테스트를 함께 실행. spring을 가동하고 spring 안에서 test가 진행되는 것</li>
              <li>@Transactional : 테스트 케이스에 이 애노테이션이 있으면, 테스트 시작 전에 트랜잭션을 시작하고, 테스트 완료 후에 항상 롤백. 즉, 각각의 test가 독립적, 반복적으로 진행되게 끔 해주는 것. 이렇게 하면 실제 DB에 영향을 주지 않음 (이게 Rollback 개념). 고로 Beforeach, Aftereach를 사용할 필요가 없음</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>DI(Dependency Injection, 의존성 주입) 직접 설정하기
        <ul>
          <li>memberservice는 기존에 각 class 자체에서 repository를 생성해서 사용 했음.</li>
          <li>이렇게 되면 service 전체에서 사용 되는 repository의 모호함이 생김. → DI 필요!</li>
          <li>memberservice를 생성할 때 생성자를 통해 자동으로 설정한 repository를 주입 시켜줌 → DI!</li>
        </ul>

        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="nf">MemberService</span><span class="o">(</span><span class="nc">MemberRepository</span> <span class="n">memberRepository</span><span class="o">)</span> <span class="o">{</span>
   <span class="k">this</span><span class="o">.</span><span class="na">memberRepository</span> <span class="o">=</span> <span class="n">memberRepository</span><span class="o">;</span> <span class="o">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong>스프링 빈과 의존관계</strong>
    <ul>
      <li>컴포넌트 스캔과 자동 의존관계 설정 (@Component[Controller, Service, Repository], @Autowired)
        <ul>
          <li>회원 컨트롤러가 회원서비스와 회원 리포지토리를 사용할 수 있게 의존관계를 준비</li>
        </ul>

        <p><img src="/images/posts/post0/2.png" alt="" /></p>

        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nd">@Controller</span>
  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemberController</span> <span class="o">{</span>
   <span class="kd">private</span> <span class="kd">final</span> <span class="nc">MemberService</span> <span class="n">memberService</span><span class="o">;</span>
   <span class="nd">@Autowired</span>
   <span class="kd">public</span> <span class="nf">MemberController</span><span class="o">(</span><span class="nc">MemberService</span> <span class="n">memberService</span><span class="o">)</span> <span class="o">{</span>
   <span class="k">this</span><span class="o">.</span><span class="na">memberService</span> <span class="o">=</span> <span class="n">memberService</span><span class="o">;</span>
   <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div>        </div>

        <ul>
          <li>@Component : 스프링 빈으로 자동 등록. 즉, 직접 인스턴스를 할당해서 다루는 것이 아니라, ComponentScanner(SpringbootAppication)이 스캔 시 확인이 가능하고 이를 Spring Container로 올려, 따로 인스턴스 할당 없이 사용됨.</li>
          <li>@Controller : controller 역할로써의 component로 Spring Bean에 등록.</li>
          <li>@Service :  service 역할로써의 component로 Spring Bean에 등록. 주로 controller에 Dependency Injection을 통해 연결(@Autowired)됨.</li>
          <li>@Repository : 리포지터리 역할로써의 component로 Spirng Bean에 등록. 주로 Service와 연결(@Autowired)됨.</li>
          <li>@Autowired : 스프링이 연관된 객체를 스프링 컨테이너에서 찾아서 넣어줌.  이렇게 객체 의존관계를 외부에서 넣어주는 것을 DI (Dependency Injection), 의존성 주입. 그렇기에 연결하려는 객체가 빈으로 등록되지 않았다면 오류 발생.</li>
        </ul>
      </li>
      <li>
        <p>@Configuration (SpringConfig)를 통해 직접 스프링 빈 등록하기</p>

        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nd">@Configuration</span>
  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpringConfig</span> <span class="o">{</span>
        
   <span class="nd">@Bean</span>
   <span class="kd">public</span> <span class="nc">MemberRepository</span> <span class="nf">memberRepository</span><span class="o">()</span> <span class="o">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nf">MemoryMemberRepository</span><span class="o">();</span>
   <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div>        </div>

        <ul>
          <li>@Configuration : Spring 환경설정 부분. Bean 등록 등 설정에 사용되는 객체라는 것을 명시</li>
          <li>@Bean : 해당 method의 반환되는 객체를 스프링 빈으로 등록함. 여기서의 Autowired 기능은 해당 객체에서 직접 설정해야 됨.</li>
          <li>실무에서는 주로 정형화된 컨트롤러, 서비스, 리포지토리 같은 코드는 컴포넌트 스캔을 사용. 하지만 정형화 되지 않거나, <strong>상황에 따라 구현 클래스를 변경해야 하면</strong> 설정을 통해 스프링 빈으로
등록한다
            <ul>
              <li>Repository 같은 경우 Bean의 mehtod의 return 값만 내가 원하는 DB로 연결하는 코드로 수정만 하면 원하는 DB로 연결 가능. 그래서 보통 repository는 따로 bean으로 등록. → 다형성을 위함!!!</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>웹 MVC 개발</strong>
    <ul>
      <li>회원가입
        <ul>
          <li>
            <p>회원 가입 시 입력되는 데이터를 전달 받을 폼 객체 생성</p>

            <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// 입력된 데이터를 전달 받을 폼 (MVC의 Model)</span>
  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemberForm</span> <span class="o">{</span>
      <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
      <span class="kd">private</span> <span class="nc">String</span> <span class="n">job</span><span class="o">;</span>
      <span class="kd">private</span> <span class="nc">String</span> <span class="n">describe</span><span class="o">;</span>
  <span class="c1">// get set 설정 필수 (생략)</span>
  <span class="o">}</span>
</code></pre></div>            </div>

            <ul>
              <li>여기서 set을 통해 입력된 값들을 저장하는 것.</li>
            </ul>
          </li>
          <li>
            <p>입력되는 정보들은 submit을 할 시, 정해진 url을 통해 PostMapping을 진행. 그 때 이 전달된 정보들을 받을 객체가 필요함.</p>

            <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nd">@PostMapping</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="s">"/join/new"</span><span class="o">)</span>
  <span class="kd">public</span> <span class="nc">String</span> <span class="nf">create</span><span class="o">(</span><span class="nc">MemberForm</span> <span class="n">form</span><span class="o">)</span> <span class="o">{</span>
   <span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">();</span>
   <span class="n">member</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="n">form</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
   <span class="n">memberService</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>
   <span class="k">return</span> <span class="s">"redirect:/"</span><span class="o">;</span>
  <span class="o">}</span>
</code></pre></div>            </div>

            <ul>
              <li>여기서 submit을 누르면 join/new 링크로 톰캣서버에 요청. 그럼 컨트롤러가 해당 link와 연결된 postmapping 의 method 실행. 이때 입력 받은 정보들은 MemberForm 객체 (form)에 할당됨. 이제 이 form객체를 통해서 DB에 저장하면 되는 것.</li>
              <li>이때 중요한 것이 html에서의 input. input의 name속성에 해당하는 이름에 맞게 객체에 저장됨.</li>
            </ul>

            <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"text"</span> <span class="na">id=</span><span class="s">"name"</span> <span class="na">name=</span><span class="s">"name"</span> <span class="na">placeholder=</span><span class="s">"이름을
  입력하세요"</span><span class="nt">&gt;</span>
</code></pre></div>            </div>

            <ul>
              <li>예를 들면 input name=”name” 이면 MemberForm의 name 속성에 setName을 통해 해당 입력 값이 저장. input name=”job” 이면 MemberForm의 job 속성에 setJob을 통해 해당 입력 값이 저장…</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>회원 조회
        <ul>
          <li>이전과 같이 GetMapping으로, Model을 실어서 진행됨.</li>
          <li>이때는 Post가 아니기에 인자로 사용되는 모델은 html파일로 넘어가는 객체임.</li>
          <li>이를 html에서 thymeleaf sytax를 통해 표현.</li>
        </ul>

        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nd">@GetMapping</span><span class="o">(</span><span class="s">"/"</span><span class="o">)</span>
      <span class="kd">public</span> <span class="nc">String</span> <span class="nf">home</span><span class="o">(</span><span class="nc">Model</span> <span class="n">model</span><span class="o">){</span>
          <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">members</span> <span class="o">=</span> <span class="n">memberService</span><span class="o">.</span><span class="na">findMembers</span><span class="o">();</span>
          <span class="n">model</span><span class="o">.</span><span class="na">addAttribute</span><span class="o">(</span><span class="s">"members"</span><span class="o">,</span> <span class="n">members</span><span class="o">);</span>
          <span class="k">return</span> <span class="s">"home"</span><span class="o">;</span>
      <span class="o">}</span>
</code></pre></div>        </div>

        <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nt">&lt;tr</span> <span class="na">th:each=</span><span class="s">"member : ${members}"</span><span class="nt">&gt;</span>
   <span class="nt">&lt;td</span> <span class="na">th:text=</span><span class="s">"${member.id}"</span><span class="nt">&gt;&lt;/td&gt;</span>
   <span class="nt">&lt;td</span> <span class="na">th:text=</span><span class="s">"${member.name}"</span><span class="nt">&gt;&lt;/td&gt;</span>
  <span class="nt">&lt;/tr&gt;</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h2 id="chapter-2">Chapter 2</h2>

<ul>
  <li>스프링 DB 접근 기술
    <ul>
      <li>h2 DataBase
        <ul>
          <li>h2.bat 실행</li>
          <li>데이터베이스 파일 생성 방법
            <ul>
              <li>jdbc:h2:~/test (최초 한번 → db 파일 생성 및 연결 - 파일모드로 접근 하는 것!)
~/test.mv.db 파일 생성 확인 (C:\Users\ <em>H2가 저장된 사용자</em>)
이후부터는 jdbc:h2:tcp://localhost/~/test 이렇게 접속 (네트워크 모드_tcp 로 접근하는 것)</li>
              <li>localhost:8082로 접근 가능 (db 파일을 생성하고 네트워크로 접근하기에 서버로써 접근이 가능한 것. 하나의 포트를 차지하고 있는 것)</li>
              <li>즉, 처음 접근 시, db파일을 만들어줌과 동시에 포트를 할당해주고, 그 이후부터는 네트워크 모드로 해당 포트로 접근하여 db를 연결하는 것. 이를 통해 springboot application(포트8080)과 db(포트8082)를 연결하여 사용할 수 있는 것.</li>
            </ul>
          </li>
          <li>
            <p>Spring Boot에 jdbc, h2 DB 관련 라이버러리 및 DataBase Source 연결 설정 추가</p>

            <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// 1. in build.gradle</span>
  <span class="n">implementation</span> <span class="err">'</span><span class="n">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">boot</span><span class="o">:</span><span class="n">spring</span><span class="o">-</span><span class="n">boot</span><span class="o">-</span><span class="n">starter</span><span class="o">-</span><span class="n">jdbc</span><span class="err">'</span>
  <span class="n">runtimeOnly</span> <span class="err">'</span><span class="n">com</span><span class="o">.</span><span class="na">h2database</span><span class="o">:</span><span class="n">h2</span><span class="err">'</span>
            
  <span class="c1">// 2. in resources/application.properties</span>
  <span class="n">spring</span><span class="o">.</span><span class="na">datasource</span><span class="o">.</span><span class="na">url</span><span class="o">=</span><span class="nl">jdbc:h2:tcp:</span><span class="c1">//localhost/~/test</span>
  <span class="n">spring</span><span class="o">.</span><span class="na">datasource</span><span class="o">.</span><span class="na">driver</span><span class="o">-</span><span class="kd">class</span><span class="err">-</span><span class="nc">name</span><span class="o">=</span><span class="n">org</span><span class="o">.</span><span class="na">h2</span><span class="o">.</span><span class="na">Driver</span>
  <span class="n">spring</span><span class="o">.</span><span class="na">datasource</span><span class="o">.</span><span class="na">username</span><span class="o">=</span><span class="n">sa</span>
  <span class="n">spring</span><span class="o">.</span><span class="na">datasource</span><span class="o">.</span><span class="na">password</span><span class="o">=</span><span class="mi">1234</span>
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
    </ul>

    <ol>
      <li>순수 Jdbc
        <ul>
          <li>JPA를 사용하지 않고 JDBC API로 직접 코딩.</li>
          <li>현재는 주로 JPA를 사용하므로 사용하지는 않는 방법. 하지만 JPA가 없던 시절 해당 방법을 통해 DB에 접근함</li>
          <li>직접 SQL문을 사용하며 이를 다루는 코드 또한 복잡하고 지속적인 예외처리가 필요하고 반복적인 코드가 다수임.</li>
          <li>
            <p>주요 코드</p>

            <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// public class JdbcMemberRepository implements MemberRepository</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">DataSource</span> <span class="n">dataSource</span><span class="o">;</span> <span class="c1">//데이터베이스 커넥션을 획득할 때 사용하는 객체</span>
            
  <span class="c1">// Constructor</span>
  <span class="kd">public</span> <span class="nf">JdbcMemberRepository</span><span class="o">(</span><span class="nc">DataSource</span> <span class="n">dataSource</span><span class="o">)</span> <span class="o">{</span> <span class="c1">//DI</span>
   <span class="k">this</span><span class="o">.</span><span class="na">dataSource</span> <span class="o">=</span> <span class="n">dataSource</span><span class="o">;</span>
   <span class="o">}</span>
</code></pre></div>            </div>

            <p>DataSource 는 DB Connection을 획들학 때 사용되는 객체. 스프링 부트는 application.properties 에서 설정한 DB Connection 정보(사용 DB, DB 서버 URL 등)를 바탕으로 DataSource를 생성하고 이를 스프링 빈으로 만들어줌. 그래서 이를 생성자에서 Dependency Injection이 가능한 것.</p>

            <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// in SpringConfig (스프링 환경설정 객체, @Configuration)</span>
  <span class="nd">@Bean</span>
   <span class="kd">public</span> <span class="nc">MemberRepository</span> <span class="nf">memberRepository</span><span class="o">()</span> <span class="o">{</span> <span class="c1">//DI</span>
  <span class="c1">// return new MemoryMemberRepository(); </span>
  <span class="k">return</span> <span class="k">new</span> <span class="nf">JdbcMemberRepository</span><span class="o">(</span><span class="n">dataSource</span><span class="o">);</span> <span class="c1">// 내가 연결하고 싶은 DB에 따라 이 한줄만 변경하면 DB에 연결됨</span>
   <span class="o">}</span>
</code></pre></div>            </div>

            <p>다형성 활용하여 코드변경 없이 연결만 변경해줌. 이 부분이 바로 스프링을 쓰는 가장 큰 이유 → 객체지향적인 설계가 좋기 때문.</p>

            <p>다형성을 굉장히 편리하게 사용할 수 있게 스프링이 컨테이너를 통해 지원함</p>
          </li>
        </ul>
      </li>
      <li>스프링 JdbcTemplate
        <ul>
          <li>순수 Jdbc와 동일한 환경설정</li>
          <li>지금도 JPA와 함께 실무에서 많이 쓰이는 DB 접근 기술</li>
          <li>스프링 JdbcTemplate과 MyBatis 같은 라이브러리는 JDBC API에서 본 반복 코드를 대부분 제거. 하지만 아직 SQL은 직접 작성해야 한다는 단점 존재.</li>
          <li>JdbcTemplate 객체 사용. 생성자를 통해 JdbcTemplate에 DataSource를 연결해줘야함.</li>
          <li>주요 코드</li>
        </ul>

        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">// public class JdbcTemplateMemberRepository implements MemberRepository</span>
 <span class="kd">private</span> <span class="kd">final</span> <span class="nc">JdbcTemplate</span> <span class="n">jdbcTemplate</span><span class="o">;</span>
        
 <span class="kd">public</span> <span class="nf">JdbcTemplateMemberRepository</span><span class="o">(</span><span class="nc">DataSource</span> <span class="n">dataSource</span><span class="o">)</span> <span class="o">{</span> <span class="c1">//DI</span>
  <span class="n">jdbcTemplate</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">JdbcTemplate</span><span class="o">(</span><span class="n">dataSource</span><span class="o">);</span>
  <span class="o">}</span>
</code></pre></div>        </div>

        <p>생성자를 통해 JdbcTemplate에 DataSource 연결</p>

        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nd">@Override</span>
 <span class="kd">public</span> <span class="nc">Member</span> <span class="nf">save</span><span class="o">(</span><span class="nc">Member</span> <span class="n">member</span><span class="o">)</span> <span class="o">{</span>
 	    <span class="nc">SimpleJdbcInsert</span> <span class="n">jdbcInsert</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SimpleJdbcInsert</span><span class="o">(</span><span class="n">jdbcTemplate</span><span class="o">);</span>
 	    <span class="n">jdbcInsert</span><span class="o">.</span><span class="na">withTableName</span><span class="o">(</span><span class="s">"member"</span><span class="o">).</span><span class="na">usingGeneratedKeyColumns</span><span class="o">(</span><span class="s">"id"</span><span class="o">);</span>
 	    <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">parameters</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
 	    <span class="n">parameters</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"name"</span><span class="o">,</span> <span class="n">member</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
 	    <span class="nc">Number</span> <span class="n">key</span> <span class="o">=</span> <span class="n">jdbcInsert</span><span class="o">.</span><span class="na">executeAndReturnKey</span><span class="o">(</span><span class="k">new</span> <span class="nc">MapSqlParameterSource</span><span class="o">(</span><span class="n">parameters</span><span class="o">));</span>
 	    <span class="n">member</span><span class="o">.</span><span class="na">setId</span><span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">longValue</span><span class="o">());</span>
 	    <span class="k">return</span> <span class="n">member</span><span class="o">;</span>
 	<span class="o">}</span>
        
 <span class="nd">@Override</span>
 <span class="kd">public</span> <span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="nf">findById</span><span class="o">(</span><span class="nc">Long</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
         <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">jdbcTemplate</span><span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="s">"select * from member where id = ?"</span><span class="o">,</span> <span class="n">memberRowMapper</span><span class="o">(),</span> <span class="n">id</span><span class="o">);</span>
         <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">findAny</span><span class="o">();</span>
     <span class="o">}</span>
        
 <span class="c1">// mapping tool</span>
 <span class="kd">private</span> <span class="nc">RowMapper</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="nf">memberRowMapper</span><span class="o">()</span> <span class="o">{</span>
 	 <span class="k">return</span> <span class="o">(</span><span class="n">rs</span><span class="o">,</span> <span class="n">rowNum</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="c1">// ReusltSet(rs)를 통해 해당 조건에 맞는 Member를 가져옴</span>
 	 <span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">();</span>
 	 <span class="n">member</span><span class="o">.</span><span class="na">setId</span><span class="o">(</span><span class="n">rs</span><span class="o">.</span><span class="na">getLong</span><span class="o">(</span><span class="s">"id"</span><span class="o">));</span>
 	 <span class="n">member</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="n">rs</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="s">"name"</span><span class="o">));</span>
 	 <span class="k">return</span> <span class="n">member</span><span class="o">;</span>
 	 <span class="o">};</span>
  <span class="o">}</span>
</code></pre></div>        </div>

        <p>JdbcTemplate이 제공하는 method들 덕분에 순수 JDBC에서 길고 반복적인 코드가 획기적으로 줄어들며 효율적으로 사용가능해짐. 하지만 여전히 SQL문은 필요로 함.</p>

        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">// in SpringConfig</span>
 <span class="nd">@Bean</span>
  <span class="kd">public</span> <span class="nc">MemberRepository</span> <span class="nf">memberRepository</span><span class="o">()</span> <span class="o">{</span> <span class="c1">//다형성</span>
 <span class="c1">// return new MemoryMemberRepository();</span>
 <span class="c1">// return new JdbcMemberRepository(dataSource);</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nf">JdbcTemplateMemberRepository</span><span class="o">(</span><span class="n">dataSource</span><span class="o">);</span> <span class="c1">// JdbcTemplat으로 연결만 바꿔주면 됨</span>
  <span class="o">}</span>
</code></pre></div>        </div>
      </li>
    </ol>
  </li>
</ul>

<ol>
  <li>JPA
    <ul>
      <li>JPA는 기존의 복잡하고 반복적인 코드는 물론이고, 기본적인 SQL도 JPA가 직접 만들어서 실행하여 훨씬 간편해짐.</li>
      <li>JPA를 사용하면, SQL과 데이터 중심의 설계에서 <strong>객체 중심의 설계</strong>로 패러다임을 전환. 즉 ORM(Object Relational Mapping, 객체 자체를 DB와 연관 지어 Mapping 하는 것). 이로 인해 JAP를 사용하면 개발 생상성 크게 증가.</li>
      <li>JPA는 일종의 interface. 이를 받는 여러 구현체들(hiberante 등)이 있음. But, 기본적으로 hibernate를 사용.</li>
      <li><code class="language-plaintext highlighter-rouge">implementation 'org.springframework.boot:spring-boot-starter-data-jpa'</code> 을 build.gradle 에 추가하여 라이브러리를 추가.  <code class="language-plaintext highlighter-rouge">spring.jpa.show-sql</code> 을 통해 해석되는 sql문을 확인할 수 있고, <code class="language-plaintext highlighter-rouge">spring.jpa.hibernate.ddl-auto=none</code> 를 통해 자동으로 Table이 생성되는 것을 방지해야 함.</li>
      <li>
        <p>주요 코드</p>

        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// in damain/Member</span>
  <span class="nd">@Entity</span> <span class="c1">// Object - Relational Mapping Annotaition</span>
  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
   <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span><span class="o">(</span><span class="n">strategy</span> <span class="o">=</span> <span class="nc">GenerationType</span><span class="o">.</span><span class="na">IDENTITY</span><span class="o">)</span> <span class="c1">// ID config</span>
   <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>
   <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
  	<span class="o">.</span>
  	<span class="o">.</span>
  <span class="o">}</span>
</code></pre></div>        </div>

        <p>@Entity : ORM에서의 Mapping 기능. 해당 Object를 RelationalDB에 Mapping 하겠다는 의미의 어노테이션</p>

        <p>@Id @GeneratedValue(strategy = GenerationType.IDENTITY) : Id 속성은 자동으로 생성되며 값이 중복되지 않아야 하므로 해당 설정을 통해 결정.</p>

        <p>나머지는 Table의 속성과 같은 이름을 가지게 하면 됨. 만약 다르다면 @Column(name = “username”) 을 통해 이름을 Mapping 시킬 수 있음</p>

        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">//	public class JpaMemberRepository implements MemberRepository</span>
        
   <span class="kd">private</span> <span class="kd">final</span> <span class="nc">EntityManager</span> <span class="n">em</span><span class="o">;</span> <span class="c1">// Jpa는 entitymanger로 모든 것을 동작함 cause ORM!!</span>
   <span class="kd">public</span> <span class="nf">JpaMemberRepository</span><span class="o">(</span><span class="nc">EntityManager</span> <span class="n">em</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// em은 스프링 내부에서 자동으로 만들어주기에 우린 injection만 해주면 됨.</span>
  	 <span class="k">this</span><span class="o">.</span><span class="na">em</span> <span class="o">=</span> <span class="n">em</span><span class="o">;</span>
   <span class="o">}</span>
        
   <span class="kd">public</span> <span class="nc">Member</span> <span class="nf">save</span><span class="o">(</span><span class="nc">Member</span> <span class="n">member</span><span class="o">)</span> <span class="o">{</span>
  	 <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member</span><span class="o">);</span> <span class="c1">// 저장</span>
  	 <span class="k">return</span> <span class="n">member</span><span class="o">;</span>
   <span class="o">}</span>
   <span class="kd">public</span> <span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="nf">findById</span><span class="o">(</span><span class="nc">Long</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
  	 <span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">id</span><span class="o">);</span> <span class="c1">// (조회할 타입, 식별자 pk)</span>
  	 <span class="k">return</span> <span class="nc">Optional</span><span class="o">.</span><span class="na">ofNullable</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>
   <span class="o">}</span>
</code></pre></div>        </div>

        <p>이전의 JdbcTemplate 보다 훨씬 간단해졌으며, SQL문도 작성하지 않아도 됨. 또한 ORM을 기반하였기에 개발 생산성이 향상됨.</p>

        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// in SpringConfig</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">EntityManager</span> <span class="n">em</span><span class="o">;</span>
        
  <span class="nd">@Bean</span>
   <span class="kd">public</span> <span class="nc">MemberRepository</span> <span class="nf">memberRepository</span><span class="o">()</span> <span class="o">{</span>
  <span class="c1">// return new MemoryMemberRepository();</span>
  <span class="c1">// return new JdbcMemberRepository(dataSource);</span>
  <span class="c1">// return new JdbcTemplateMemberRepository(dataSource);</span>
   <span class="k">return</span> <span class="k">new</span> <span class="nf">JpaMemberRepository</span><span class="o">(</span><span class="n">em</span><span class="o">);</span>
   <span class="o">}</span>
</code></pre></div>        </div>
      </li>
      <li>추가로 JPA를 통한 모든 데이터 변경은 트랜잭션 안에서 실행해야 하므로 @Service Component에 @Transaction 추가 필수.</li>
    </ul>
  </li>
  <li>스프링 데이터 JPA
    <ul>
      <li>이미 스프링 부트와 JPA를 통해 개발 생산성이 많이 증가했지만 스프링 데이터 JPA는 마법처럼 인터페이스 +  추가적인 구현 클래스 없이 인터페이스 만으로 리포지토리를 개발할 수 있음. 또한,  CRUD 기능도 스프링 데이터 JPA가 모두 제공.</li>
      <li>Class가 아닌 Interface로 사용하며 JpaRepository&lt;E, key&gt; 사용.
JpaRepository를 상속받으면 자동으로 컴포넌트 스캐너가 인식하여 이를 빈으로 등록함.</li>
      <li>
        <p>주요 코드</p>

        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">interface</span> <span class="nc">SpringDataJpaMemberRepository</span> <span class="kd">extends</span> <span class="nc">JpaRepository</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">,</span>
  <span class="nc">Long</span><span class="o">&gt;,</span> <span class="nc">MemberRepository</span> <span class="o">{</span>
  	 <span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="nf">findByName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">);</span>
  <span class="o">}</span> <span class="c1">// </span>
</code></pre></div>        </div>

        <p>이렇게 단 한줄로 이름으로 Member를 찾는게 가능해짐. → 스프링 데이터 JPA가 모두 구현 했기 때문, 또한 findBY00 형식을 지켜 원하는 속성으로 데이터를 찾아낼 수도 있음. 혁신 그 자체.</p>

        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nd">@Configuration</span>
  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpringConfig</span> <span class="o">{</span>
  	 <span class="kd">private</span> <span class="kd">final</span> <span class="nc">MemberRepository</span> <span class="n">memberRepository</span><span class="o">;</span>
        	
  	 <span class="nd">@Autowired</span> <span class="c1">// 생략 가능</span>
  	 <span class="kd">public</span> <span class="nf">SpringConfig</span><span class="o">(</span><span class="nc">MemberRepository</span> <span class="n">memberRepository</span><span class="o">)</span> <span class="o">{</span>
  	 <span class="k">this</span><span class="o">.</span><span class="na">memberRepository</span> <span class="o">=</span> <span class="n">memberRepository</span><span class="o">;</span>
  	<span class="o">}</span>
        
  <span class="nd">@Bean</span>
  <span class="kd">public</span> <span class="nc">MemberService</span> <span class="nf">memberService</span><span class="o">()</span> <span class="o">{</span>
  		<span class="k">return</span> <span class="k">new</span> <span class="nf">MemberService</span><span class="o">(</span><span class="n">memberRepository</span><span class="o">);</span>
  	 <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div>        </div>

        <p>스프링 데이터 JPA가 SpringDataJpaMemberRepository 를 스프링 빈으로 자동 등록</p>
      </li>
    </ul>
  </li>
</ol>

<ul>
  <li><strong>AOP</strong>
    <ul>
      <li>AOP : Aspect Oriented Programming</li>
      <li>모든 메소드의 호출 시간을 측정하고 싶을 때와 같이 공통 관심 사항에 대해 구현하고 싶은 것이 생길 때 쓰는 기술.</li>
      <li>모든 메소드에 대해 각 시간 측정 코드를 추가하는 것이 아닌 AOP 하나만으로 모든 메서드에 적용.</li>
      <li>즉, 공통 관심 사항(cross-cutting concern)과 핵심 관심 사항(core concern)을 명확히 구분하여 효율적인 개발을 위한 기술</li>
      <li>
        <p>AOP는 DI가 존재하기에 가능한 기술. → 내가 만약 DI를 설정하지 않고 직접 연결했다고 하면 당연히 각 코드별로 AOP에 해당하는 기능을 넣어줘야 함. 하지만, DI가 있기에 AOP를 따로 만들어주기만 하면 DI에 따라 AOP가 자동으로 실행되는 것.</p>

        <p><img src="/images/posts/post0/3.png" alt="가짜 객체(프록시)를 만들어 해당 객체에 접근하기 전에 이를 인지할 수 있도록 함" />
가짜 객체(프록시)를 만들어 해당 객체에 접근하기 전에 이를 인지할 수 있도록 함</p>

        <p><img src="/images/posts/post0/4.png" alt="Untitled" /></p>
      </li>
      <li>주요 코드</li>
    </ul>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nd">@Component</span>
  	<span class="nd">@Aspect</span>
  	<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TimeTraceAop</span> <span class="o">{</span>
  		 <span class="nd">@Around</span><span class="o">(</span><span class="s">"execution(* hello.hellospring..*(..))"</span><span class="o">)</span>
  		 <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">execute</span><span class="o">(</span><span class="nc">ProceedingJoinPoint</span> <span class="n">joinPoint</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{</span>
  			 <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
  			 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"START: "</span> <span class="o">+</span> <span class="n">joinPoint</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
  			 <span class="k">try</span> <span class="o">{</span>
  				 <span class="k">return</span> <span class="n">joinPoint</span><span class="o">.</span><span class="na">proceed</span><span class="o">();</span>
  			 <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
  				 <span class="kt">long</span> <span class="n">finish</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
  				 <span class="kt">long</span> <span class="n">timeMs</span> <span class="o">=</span> <span class="n">finish</span> <span class="o">-</span> <span class="n">start</span><span class="o">;</span>
  				 <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"END: "</span> <span class="o">+</span> <span class="n">joinPoint</span><span class="o">.</span><span class="na">toString</span><span class="o">()+</span> <span class="s">" "</span> <span class="o">+</span> <span class="n">timeMs</span> <span class="o">+</span> <span class="s">"ms"</span><span class="o">);</span>
  			 <span class="o">}</span>
  			<span class="o">}</span>
  <span class="o">}</span>
</code></pre></div>    </div>

    <p>시간을 측정하는 로직을 별도의 공통 로직으로 만들어 회원가입, 회원 조회등 핵심 관심사항과 시간을 측정하는 공통 관심 사항을 분리. 고로 핵심 관심 사항을 깔끔하게 유지 가능. 변경이 필요할 때 해당 AOP만 수정해주면 되며 적용 대상을 직접 선택할 수 있음.</p>
  </li>
</ul>
:ET